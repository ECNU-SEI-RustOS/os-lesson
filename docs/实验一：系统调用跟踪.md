#### 实验一：系统调用跟踪

**实验要求**

在本次实验中，你将为内核添加一个 **系统调用跟踪功能**，这个功能在你调试后续实验时将会非常有帮助。

你需要实现一个新的系统调用：`trace`。该系统调用用于控制追踪行为，它接受一个参数：一个整数类型的“**掩码（mask）**”。这个掩码的每一位代表一个系统调用，若某一位被设置为 1，则表示需要追踪对应编号的系统调用。

例如，若希望追踪 `fork` 系统调用，一个程序可以调用：

```c
trace(1 << SYS_fork);
```

其中，`SYS_fork` 是 `include/syscall.h` 中定义的系统调用编号。

你需要对内核进行修改，使其在每个系统调用即将返回结果时，判断是否需要输出追踪信息。若该系统调用的编号在当前掩码中被设置，则输出一行追踪信息。追踪信息包括：

- 当前进程的 PID（进程号）
- 系统调用的名称
- 返回值

**注意**：你不需要打印系统调用的参数。

此外，`trace` 系统调用只对当前调用它的进程及该进程随后通过 `fork` 创建的子进程生效，对其他进程没有影响。

------

**实验现象**

我们提供了一个名为 `trace` 的用户态程序，用于在启用追踪功能的情况下运行另一个程序（见 `user/trace.c`）。完成实验后，你应该会看到类似如下的输出结果：

```
/* 示例1 */
$ trace 32 grep hello README
2: syscall read -> 1023
2: syscall read -> 966
2: syscall read -> 70
2: syscall read -> 0
/* 示例2 */
$ trace 2147483647 grep hello README
3: syscall trace -> 0
3: syscall exec -> 3
3: syscall open -> 3
3: syscall read -> 1023
3: syscall read -> 966
3: syscall read -> 70
3: syscall read -> 0
3: syscall close -> 0
/* 示例3 */
$ grep hello README
/* 示例4 */
$ trace 2 usertests forkforkfork
usertests starting
5: syscall fork -> 6
test forkforkfork: 5: syscall fork -> 7
7: syscall fork -> 8
8: syscall fork -> 9
8: syscall fork -> 10
9: syscall fork -> 11
8: syscall fork -> 12
10: syscall fork -> 13
......
......
OK
5: syscall fork -> 71
ALL TESTS PASSED
```

在上面的几个示例中，trace 的行为如下：

1. **第一个示例中**，trace 仅追踪了 `read` 系统调用。数字 32 是 `1 << SYS_read` 的结果，表示只追踪编号为 `SYS_read` 的系统调用。
2. **第二个示例中**，trace 运行 grep 时追踪了所有的系统调用。数值 `2147583647` 的二进制形式是低 31 位全为 1，表示开启所有系统调用的追踪。
3. **第三个示例中**，程序未启用追踪功能，因此不会有任何追踪输出。
4. **第四个示例中**，运行 usertests 中的 `forkforkfork` 测试，追踪的是所有子进程中的 `fork` 系统调用。

只要你的程序运行行为与上述描述一致（尽管具体的进程 ID 可能会有所不同），就说明你的实现是正确的。

------

**实现提示**

1. **在 Makefile 中添加可执行目标**
    在 `Makefile` 中的 `UPROGS` 列表中添加一项：`$(USER)/_trace\`，用于编译用户态的 `trace` 程序。

2. **构建系统调用接口原型**
    运行 `make qemu` 后你会发现系统无法编译 `user/trace.c`，因为你还没有为新的系统调用添加用户态的接口。这部分工作包括：

   - 在 `user/user.h` 中添加 `trace` 的函数声明；
   - 在 `user/usys.pl` 中添加 `trace` 的名字，用于自动生成汇编包装代码；
   - 在 `include/syscall.h` 中为 `trace` 分配一个新的系统调用编号。

   `Makefile` 会调用 `user/usys.pl` 脚本，它会生成 `user/usys.S` 文件，这个文件包含系统调用的用户态包装函数，它们会通过 RISC-V 的 `ecall` 指令切换到内核态。

3. **实现内核中的系统调用处理逻辑**
    修复用户程序编译后，再次运行 `trace 32 grep hello README`，你会发现程序仍然报错，因为此时 `trace` 系统调用尚未在内核中实现。

   - 在 `src/process/proc/syscall.rs` 中添加一个新的 `sys_trace()` 函数；
   - 该函数需要将传入的 `mask` 参数存储到当前进程的 `proc` 结构体中（见 `src/process/proc/mod.rs`），用于后续判断是否追踪；
   - 获取系统调用参数可以调用 `src/process/proc/syscall.rs` 中已有的参数提取函数，具体用法可以参考 `syscall.rs` 中的其他系统调用实现。

4. **在进程派生时复制追踪设置**
    修改 `src/process/proc/mod.rs` 中的 `fork()` 实现，使得父进程的追踪掩码能正确地复制给子进程。

5. **在 syscall 分发函数中实现打印逻辑**
    修改 `src/process/proc/syscall.rs` 中的 `syscall()` 函数，实现在系统调用返回前判断是否启用了追踪，如果是，则打印追踪信息。你需要：

   - 添加一个系统调用名称字符串数组，方便通过系统调用编号进行查找；
   - 在正确的位置打印进程 ID、系统调用名称和返回值等信息。