#### 实验三：打印页表

**实验要求**

为了帮助你更直观地理解 RISC-V 的页表结构，同时也便于将来的调试工作，你的任务是：**实现一个函数，用于打印当前进程的页表内容**。你需要定义一个名为 `vmprint()` 的函数。该函数接受一个 `pagetable` 类型的参数，并以特定格式打印该页表的内容（格式要求将在后续实验说明中详细介绍）。这个打印函数的目标是清晰地展示虚拟页与物理页的映射关系，以及页表的层次结构。

为验证你的实现，请在 `syscall.rs` 文件中，在`sys_exec`函数插入如下代码：

```rust
let guard = self.excl.lock();
if guard.pid == 1 {
    let data = self.data.get_mut();
    data.pagetable.as_ref().unwrap().vm_print(0);
}
drop(guard);
```

这段代码会在第一个用户进程执行时自动打印其页表信息。

只要你能够通过 `make grade` 中与页表打印相关的测试用例（即 `pte printout` 测试），就可以获得该实验部分的**满分**。

------

**实验现象**

现在当你启动时，应该会看到类似如下的输出，描述的是**第一个进程在刚刚完成 `sys_exec()` 调用后**的页表内容：

```
page table 0x80409000
..0: pte 0x20103401 pa 0x8040d000
.. ..0: pte 0x20103801 pa 0x8040e000
.. .. ..0: pte 0x20103801 pa 0x8040e000
..255: pte 0x20102801 pa 0x8040a000
.. ..511: pte 0x20102c01 pa 0x8040b000
.. .. ..511: pte 0x20102c01 pa 0x8040b000
```

打印输出的第一行显示的是传入 `vmprint` 函数的参数（即页表的起始地址）。随后每一行对应一个有效的页表项（PTE），包括那些指向更深层级页表页的中间页表项。

每一行页表项之前会有若干个 `" .."` 缩进，缩进的数量表示该页表项所在页表在页表树中的层级深度（顶层为 0，越往下层缩进越多）。

每一行页表项的输出内容包括：

- 该页表项在当前页表页中的索引；
- 页表项的控制位（如有效位、用户位、读写权限等）；
- 从页表项中提取出的物理页地址。

注意：**不要打印无效的页表项**（即 `valid` 位未置位的 PTE）。

在上面的输出示例中，顶层页表页中映射了第 0 项和第 255 项；对于第 0 项指向的下一级页表中，仅第 0 项被映射；而该页表中的第 0 项再进一步指向底层页表，其中第 0、1、2 项被映射。

你实现的代码可能会打印出与示例中不同的物理地址，但映射的项数以及它们对应的虚拟地址索引应当是一致的。

------

**实验提示**

- 你可以将 `vmprint()` 函数的实现放在 `mm/pagetable.rs` 文件中；
- 在实现过程中，可以使用 `const/riscv.h` 文件末尾定义的一些宏，这些宏能帮助你处理页表项的位操作；
- 可以参考函数 `walk` 的实现思路，它同样是递归地遍历多级页表结构；
- 在Rust的`println`宏中使用`{:x}`打印十六进制数