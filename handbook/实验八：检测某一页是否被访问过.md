#### 实验八：检测某一页是否被访问过

**实验内容**

一些垃圾回收器（即自动内存管理的一种形式）可以通过知道哪些页面在运行中被访问过（包括读或写）来优化其性能。在本实验的这一部分中，你需要为内核添加一个新功能，利用 RISC-V 页表中的访问标志（access bit），检测用户空间中哪些页面被访问过，并将这些信息报告给用户程序。在 RISC-V 架构下，每当处理器遇到一次 TLB 未命中（即缺页）时，硬件的页表遍历器（page walker）会将相应的访问位（Accessed bit）标记在页表项（PTE）中。

你的任务是实现一个新的系统调用 `pgaccess()`，它能够返回哪些页面已经被访问过。这个系统调用需要三个参数：

1. 要检测的第一个用户页的起始虚拟地址；
2. 要检测的页面数量；
3. 一个用户地址，指向结果存储缓冲区，该缓冲区以位掩码（bitmask）的形式表示每页的访问情况（每页用一位表示，第一页对应最低有效位）。

当你实现的 `pgaccess()` 成功通过 `pgtbltest` 测试程序中的 `pgaccess` 测试用例时，即可获得本实验部分的满分。

------

**实验提示**

- 从实现 `sys_pgaccess()` 函数入手，放在 `process/proc/syscall.rs` 中。
- 你需要使用 `arg_addr()` 和 `arg_i32()` 来解析系统调用的参数（分别用于获取用户传入的地址和整数）。
- 对于输出的位掩码，建议在内核中先使用一个临时缓冲区，填充完结果后，再通过 `copy_out()` 将其拷贝回用户空间。
- 可以为最多可检测的页面数量设置一个上限，简化实现逻辑。
- `mm/pagetable.rs` 中的 `walk()` 函数对于查找特定虚拟地址对应的页表项（PTE）非常有用，推荐使用。
- 你需要在 `const/riscv.h` 中定义 `PTE_A`，即页表项中的访问标志（Accessed Bit）。该标志的具体值可以参考 RISC-V 架构手册进行确定。
- 检查完访问位是否被设置后，**一定要清除该位（PTE_A）**。否则下一次调用 `pgaccess()` 时将无法判断访问位是否是本次新产生的，因为访问位会一直保持为1。
- 在调试页表时，`vmprint()` 函数可能会很有帮助，它可以打印出当前进程的页表结构信息。