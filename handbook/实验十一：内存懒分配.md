#### 实验十一：内存懒分配

**实验背景**

操作系统与页表硬件配合时，可以使用懒分配来优化用户空间堆内存的管理。xv6中的应用程序通过`sbrk()`系统调用请求堆内存。在给定的内核中，`sbrk()`会分配物理内存并将其映射到进程的虚拟地址空间。当请求内存较大时，内核分配和映射内存的过程可能需要较长时间。例如，一个千兆字节包含262,144个4096字节的页面；即使每个分配操作很便宜，这样的请求依然需要大量的分配。此外，一些程序分配的内存超过实际需要的内存（例如实现稀疏数组），或提前分配内存以便后续使用。为了让`sbrk()`在这些情况下能更快完成，先进的内核会采用懒分配的方式。也就是说，`sbrk()`不会立即分配物理内存，而是记住哪些用户地址已经分配，并将这些地址在用户页表中标记为无效。当进程第一次尝试使用任何懒分配的内存页面时，CPU会触发一个页面错误，内核通过分配物理内存、清零并映射它来处理该错误。

**实验内容**

步骤一：移除`sbrk()`中的内存分配

你的第一个任务是删除`sbrk()`系统调用实现中的页面分配，位于`proc/mod.rs`中。`sbrk()`系统调用通过增加`n`字节来扩展进程的内存大小，然后返回新分配区域的起始位置（即原来的大小）。你的新实现应该只是将进程的大小（`ProcData.sz`）增加`increment`，并返回原来的大小，而无需进行内存分配。因此，你需要删除对`uvm_alloc()`的调用（但你仍然需要增加进程的大小！）。

完成修改后，编译启动系统内核，并执行`echo hi`，可以看到如下效果：

```
init: starting sh
$ echo hi
scause 0xf
sepc=0x12a4 stval=0x4008
```

步骤二：实现内存懒分配

修改`trap.rs`中的代码，以响应来自用户空间的页面错误，通过在错误地址处映射一个新分配的物理内存页面，然后返回用户空间让进程继续执行。你应该在产生“usertrap(): ...”消息的`printf`调用之前添加你的代码。根据需要修改其他内核代码，以确保`echo hi`能够正常运行。

**实验提示**

- 通过检查`usertrap()`中的`r_scause()`是否为13或15来判断是否为页错误。
- 使用`r_stval()`获取引发页面错误的虚拟地址。
- 参考中`uvm_alloc()`的代码，因为`sbrk()`通过`growproc()`调用它。需要调用`kalloc()`和`mappages()`。
- 使用`pg_round_down()`将错误的虚拟地址舍入到页面边界。
- 修改`uvm_unmap() uvm_copy() try_clone()`，避免在某些页面未映射时触发panic。

**可参考的更优实现**

- 处理负的`sbrk()`参数。
- 如果进程在一个虚拟内存地址上发生页面错误，并且该地址高于任何通过`sbrk()`分配的地址，终止该进程。
- 正确处理`fork()`中的父子进程内存拷贝。
- 处理进程将从`sbrk()`获得的有效地址传递给系统调用（如`read`或`write`）的情况，但该地址的内存尚未分配。
- 正确处理内存不足的情况：如果`kalloc()`在页面错误处理程序中失败，终止当前进程。
- 处理位于用户栈下方的无效页面错误。

说明：受限于Rust语言更强的内存安全设计，本实验只需要通过lazytests用户程序测试即可

一个可以接受的设计运行效果如下：

```
$ lazytests
lazytests starting
running test lazy alloc
test lazy alloc: OK
running test out of memory
test out of memory: OK
ALL TESTS PASSED
```

#### 