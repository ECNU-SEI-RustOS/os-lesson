#### 实验二：加速系统调用

**实验要求**

在某些操作系统（如 Linux）中，为了提升系统调用的性能，会通过在用户态与内核之间共享只读内存区域的方式来加速特定系统调用。这样一来，在执行这些系统调用时，就无需频繁陷入内核态（kernel crossing），从而减少开销。你的任务是：为 `getpid()` 系统调用实现这种优化机制。

- 在每个新进程创建时，在其地址空间中映射一个只读页面，该页面的虚拟地址为 `USYSCALL`（定义在 `memlayout.h` 中）。
- 在该页面的起始位置，放置一个名为 `struct usyscall` 的结构体（同样定义在 `memlayout.h` 中），并初始化其中的字段，使其保存当前进程的 PID。
- 用户态已经提供了 `ugetpid()` 函数，它会自动从 `USYSCALL` 映射读取数据。因此，无需你修改用户态的相关代码。
- 如果在运行 `pgtbltest` 时，`ugetpid` 的测试用例能够通过，你将获得本部分实验的满分。

------

**实验提示**

- 你可以在 `src/process/proc/mod.rs` 文件中的 `alloc_proc_pagetable()` 函数中完成页面映射操作。在该函数中，构建的是进程的页表结构，因此此处是插入只读共享页面映射的合适位置。
- 请设置合适的权限位，确保用户态只能读取该页面。由于该页面仅用于暴露进程的只读信息（如 PID），必须严格禁止写权限，防止用户空间修改其内容。
- 你可能会发现 `map_pages()` 函数很有用。该函数用于在页表中插入一段虚拟地址到物理地址的映射，并设置权限，是实现该功能的关键工具函数。
- 不要忘了在 `alloc_proc()` 中分配并初始化这个页面。`alloc_proc()` 是创建新进程时进行资源初始化的地方，你需要在这里为 `usyscall` 结构体分配一页物理内存，并将当前进程的 PID 写入结构体中。
- 别忘了在 `cleanup()` 中释放该页面。当进程被销毁时，其使用的资源需要被回收，包括你在 `alloc_proc()` 中分配的只读共享页面，避免内存泄漏。