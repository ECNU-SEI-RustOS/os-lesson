### 参考实现

#### 实验一：进行系统调用

**C语言实现**

```c
int
main(int argc, char *argv[])
{
  // 如果命令行参数数量不是 2（程序名 + 1 个参数），说明用户未传入 sleep 时长
  if (argc != 2) {
    // 向标准输出（fd = 1）打印错误信息
    write(1, "Error Argument\n", 16);
  }
  else {
    // 将字符串参数转换为整数，作为 sleep 的时间（单位为 tick）
    sleep(atoi(argv[1]));
  }

  // 程序执行完毕，调用 exit 正常退出
  exit(0);
}

```

**Rust语言实现**

```rust
#![no_std]                // 告诉编译器不链接 Rust 标准库（std），适用于内核/嵌入式/操作系统环境
#![no_main]               // 禁用 Rust 默认的入口点 `fn main()`，因为我们自己定义了 main 函数

use user_rust_lib::task::sleep;  // 从用户态库中引入 sleep 函数，封装了系统调用

// 引入宏定义，例如封装的 `println!`、`syscall!` 等，来自 user_rust_lib 库
#[macro_use]
extern crate user_rust_lib;

#[no_mangle]              // 禁止 Rust 对函数名进行名称改编，以便让操作系统正确识别 main 函数符号
fn main(argc: usize, argv: &[&str]) -> i32 {
    // 调用 sleep 函数让进程睡眠 10 个 tick（xv6 中的时间单位）
    sleep(10);

    // 返回 0 表示正常退出
    0
}

```

#### 实验二：打乒乓

**C语言实现**

```c
int
main(int argc, char *argv[])
{
  int p1[2], p2[2];                 // 创建两个管道：p1 用于子进程 -> 父进程，p2 用于父进程 -> 子进程
  char foo[10];                     // 用于接收管道中传输的数据的缓冲区

  pipe(p1);                         // 初始化管道 p1
  pipe(p2);                         // 初始化管道 p2

  if(fork() == 0) {                 // 创建子进程；子进程执行此分支
    // 子进程逻辑
    if(read(p2[0], foo, sizeof(foo)) != 0) {  // 从父进程的写端读取消息（通过 p2[0]）
        printf("%d: received ping\n", getpid()); // 打印“收到 ping”的消息
        write(p1[1], "CHILD", 6);   // 将字符串 "CHILD" 通过 p1 写给父进程
    }
    exit(0);                        // 子进程结束
  }
  else {
    // 父进程逻辑
    write(p2[1], "PARENT", 7);      // 将字符串 "PARENT" 写入 p2，发送给子进程
    if(read(p1[0], foo, sizeof(foo)) != 0) {  // 从子进程读取返回的信息
        wait(0);                    // 等待子进程结束
        printf("%d: received pong\n", getpid()); // 打印“收到 pong”的消息
    }
    exit(0);                        // 父进程结束
  }
}

```

**Rust语言实现**

```rust
pub fn main() -> i32 {
    let mut p1 = [0; 2]; // 定义第一个管道 p1：用于 子 -> 父 的通信（子写父读）
    let mut p2 = [0; 2]; // 定义第二个管道 p2：用于 父 -> 子 的通信（父写子读）
    let mut buf = [0u8; 10]; // 定义接收缓冲区，用于存放管道中读取的消息

    pipe(&mut p1); // 创建管道 p1（将两个文件描述符写入 p1）
    pipe(&mut p2); // 创建管道 p2（将两个文件描述符写入 p2）

    if fork() == 0 {
        // 子进程执行逻辑

        // 从 p2 的读端读取来自父进程的数据
        if read(p2[0] as isize, &mut buf) != 0 {
            // 如果成功读取，则打印收到 ping 的消息，包含子进程的 PID
            println!("{}: received ping", getpid());

            // 通过 p1 的写端向父进程发送 "CHILD" 消息
            user_rust_lib::file::write(p1[1] as isize, b"CHILD");
        }

        exit(0) // 子进程结束
    } else {
        // 父进程执行逻辑

        // 通过 p2 的写端向子进程发送 "PARENT" 消息
        user_rust_lib::file::write(p2[1] as isize, b"PARENT");

        // 从 p1 的读端接收来自子进程的响应
        if read(p1[0] as isize, &mut buf) != 0 {
            // 等待子进程退出，传入一个 dummy 的指针
            wait(&mut 0);

            // 打印收到 pong 的消息，包含父进程的 PID
            println!("{}: received pong", getpid());
        }

        exit(0); // 父进程结束
    }
}

```

#### 实验三：并发素数筛

**C语言实现**

```c
void
pipeline(int *in_pipe){              // 递归构建管道处理链，每个进程负责一个素数筛选
  int out_pipe[2];                   // 用于传递未被当前素数过滤的数值给下一个进程的管道
  int buf;                           // 缓冲区，用于存储读取到的整数
  int head;                          // 当前进程负责筛选的素数
  pipe(out_pipe);                    // 创建新的输出管道

  if(read(in_pipe[0], &head, 4)){    // 从输入管道读取一个整数作为“当前素数”
    if(head >= 35){                  // 若当前数 >= 35，终止递归构建
      return;
    }
  }
  else{                              // 如果读不到数据，说明已经结束，直接返回
    return;
  }

  if(fork() == 0){                   // 子进程负责处理下一个素数
    close(out_pipe[1]);              // 子进程不写，只读，所以关闭写端
    pipeline(out_pipe);             // 递归进入下一层，处理下一个素数
  }
  else{                              // 父进程：筛选非当前素数的数值并写入输出管道
    printf("prime %d\n", head);      // 打印当前进程筛选出的素数
    while(read(in_pipe[0], &buf, 4)){// 持续从输入管道读取整数
      if(buf % head != 0){           // 如果不能被当前素数整除，传给下一个进程
        write(out_pipe[1], &buf, 4);
      }
    }
    close(in_pipe[0]);               // 输入处理完毕，关闭输入管道
    close(out_pipe[1]);              // 输出也完成，关闭输出管道
    wait(0);                         // 等待子进程结束，确保输出顺序一致
  }
  return;
}

int
main(int argc, char *argv[])
{
  int in_pipe[2];                    // 主进程使用的初始输入管道
  pipe(in_pipe);                     // 创建主进程的输出管道

  if(fork() == 0){                   // 子进程负责启动 pipeline 递归处理
    close(in_pipe[1]);               // 子进程只读关闭写端
    pipeline(in_pipe);              // 启动筛选流程
  }
  else{
    close(in_pipe[0]);               // 父进程只写，关闭读端
    for(int i = 2; i < 35; i++){     // 将 2~34 写入到管道中，作为待筛选的整数序列
      write(in_pipe[1], &i, 4);
    }
    close(in_pipe[1]);               // 写入完毕后关闭写端，表示写完了
    wait(0);                         // 等待子进程处理完所有筛选
  }
  exit(0);                           // 程序结束
}

```

**Rust语言实现**

```rust
#[no_mangle]                       // 防止函数名被 Rust 编译器修改，保证可以被内核识别为 `main`
pub fn main(){
    let mut in_pipe = [0u32; 2];   // 创建一个整数数组用于 pipe，作为主进程写入和子进程读取的管道
    let _ = pipe(&mut in_pipe);    // 创建 pipe，in_pipe[0] 为读端，in_pipe[1] 为写端

    if fork() == 0 {               // 创建子进程处理筛选流程
        let _ = close(in_pipe[1] as isize);  // 子进程不写，只读，关闭写端
        pipeline(in_pipe);                   // 启动递归的管道处理函数
    } else {
        let _ = close(in_pipe[0] as isize);  // 父进程不读，只写，关闭读端
        for i in 2..35 {                     // 将 2~34 的整数写入管道
            let n = i as u32;                // 强制转换为 u32 类型
            let _ = user_rust_lib::file::write(in_pipe[1] as isize, &n.to_ne_bytes()); // 写入整数的字节表示
        }
        let _ = close(in_pipe[1] as isize);  // 所有数字写入完毕后关闭写端
        let _ = wait(&mut 0);                // 等待子进程执行完毕
    }

    exit(0);                                 // 主进程退出
}
fn pipeline(in_pipe: [u32; 2]) {
    let mut out_pipe = [0u32; 2];           // 输出管道，用于传递剩余待筛选的数字
    let _ = pipe(&mut out_pipe);            // 创建新管道

    let mut buf = [0u8; 4];                 // 字节缓冲区，用于读取整数
    let mut head = 0u32;                    // 当前进程筛选的素数

    if read(in_pipe[0] as isize, &mut buf) == 0 {
        return;                             // 如果读取失败（管道关闭），直接返回
    }
    head = u32::from_ne_bytes(buf);         // 将读到的 4 字节转换为整数
    if head >= 35 {                         // 若超出范围，不再筛选，直接返回
        return;
    }

    if fork() == 0 {                        // 为下一个素数创建新进程
        let _ = close(out_pipe[1] as isize); // 子进程只读，不写，关闭写端
        pipeline(out_pipe);                 // 递归进入下一层处理
    } else {
        println!("prime {}", head);         // 输出当前发现的素数
        loop {
            let nread = read(in_pipe[0] as isize, &mut buf); // 从输入管道持续读取数据
            if nread == 0 {
                break;                      // 如果读取结束（管道写端关闭），退出循环
            }
            let val = u32::from_ne_bytes(buf);               // 将字节转换为整数
            if val % head != 0 {                             // 若不能被当前素数整除
                let _ = user_rust_lib::file::write(out_pipe[1] as isize, &val.to_ne_bytes()); // 写入输出管道
            }
        }
        let _ = close(in_pipe[0] as isize);   // 输入处理完毕，关闭读端
        let _ = close(out_pipe[1] as isize);  // 输出完成，关闭写端
        let _ = wait(&mut 0);                 // 等待子进程结束，保证输出顺序
    }
}

```

#### 实验四：文件查找

**参考实现**

```c
// 返回路径中最后一级文件名（带处理长度限制）
char*
fmtname(char *path)
{
  static char buf[DIRSIZ+1];     // 用于存放格式化后的文件名
  char *p;

  // 从路径末尾向前查找最后一个 '/'，以获取文件名
  for(p=path+strlen(path); p >= path && *p != '/'; p--)
    ;

  p++;  // 指向文件名开始的字符

  if(strlen(p) >= DIRSIZ)        // 若文件名已经足够长（无需补齐）
    return p;

  // 若文件名较短，拷贝到缓冲区并补齐 \0
  memmove(buf, p, strlen(p));
  memset(buf+strlen(p), '\0', DIRSIZ-strlen(p));
  return buf;
}

// 递归查找以 path 为根目录下所有名为 name 的文件
void
find(char *path, char *name)
{
  char buf[512], *p;             // buf 用于拼接路径，p 用于遍历目录项
  int fd;                        // 打开目录用到的文件描述符
  struct dirent de;             // 目录项结构体
  struct stat st;               // 文件状态结构体

  // 尝试打开路径
  if((fd = open(path, 0)) < 0){
    fprintf(2, "find: cannot open %s\n", path);
    return;
  }

  // 获取路径对应的文件状态
  if(fstat(fd, &st) < 0){
    fprintf(2, "find: cannot stat %s\n", path);
    close(fd);
    return;
  }

  // 根据类型分类处理（这里只处理目录）
  switch(st.type) {
    case T_DIR:
      strcpy(buf, path);        // 将当前路径拷贝到 buf 中
      p = buf+strlen(buf);      // p 指向路径末尾
      *p++ = '/';               // 在路径末尾添加斜杠准备拼接文件名

      // 遍历目录项
      while(read(fd, &de, sizeof(de)) == sizeof(de)){
        if(de.inum == 0 || !strcmp(de.name,".") || !strcmp(de.name,".."))
          continue;             // 跳过空项和 .、..

        memcpy(p, de.name, DIRSIZ); // 拼接完整路径
        p[DIRSIZ] = 0;              // 添加字符串结尾

        int fd_sub = open(buf, 0);  // 打开拼接后的路径
        struct stat st_sub;
        fstat(fd_sub, &st_sub);    // 获取该路径的 stat 信息

        if(st_sub.type == T_FILE){ // 如果是文件，比较文件名是否匹配
          if(!strcmp(name, fmtname(buf))){
            printf("%s\n", buf);   // 如果匹配，打印路径
          }
        }
        else if(st_sub.type == T_DIR) {
          find(buf, name);         // 是目录，递归进入查找
        }
        close(fd_sub);             // 关闭子路径文件描述符
      }
    break;
  }

  return;
}

int
main(int argc, char *argv[])
{
  find(argv[1], argv[2]);         // 调用 find，从指定路径开始查找指定文件名
  exit(0);                        // 程序结束
}

```

------

#### 实验五：系统调用跟踪

**添加系统调用号定义**

**文件**：`include/syscall.h`

```c
#define SYS_trace  22
```

**解释**：
 此处添加了 `trace` 系统调用的编号。
 其中 `SYS_trace` = 22 是本实验的核心新增系统调用，用于控制系统调用追踪掩码。

------

**为进程结构体添加 trace 掩码字段**

**文件**：`src/process/proc/mod.rs`

```rust
pub tracemask: usize,
```

初始化时设置为 0：

```rust
tracemask: 0,
```

**解释**：
 添加 `tracemask` 字段用于记录当前进程启用了哪些系统调用的追踪。它是一个位图掩码，按位表示系统调用是否开启追踪。

------

**系统调用处理逻辑中添加追踪输出**

**文件**：`src/process/proc/mod.rs`

```rust
22 => self.sys_trace(),  // 注册 trace 调用处理

// syscall 返回后输出追踪信息
let guard = self.excl.lock();
let pid = guard.pid;
let tracemask = self.data.get_mut().tracemask;
if tracemask & (1 << a7) != 0 {
    println!("{}: syscall {} -> {}", pid, syscall::SYSCALL_NAME[a7], tf.a0 as isize);
}
drop(guard);
```

**解释**：

- 为 syscall 分发函数添加了 `SYS_trace` 的处理路径；
- 在系统调用返回前判断当前进程的 `tracemask` 中是否包含当前系统调用（通过位掩码判断 `1 << a7`）；
- 若需要追踪，打印出进程号、系统调用名称和其返回值。

------

**fork 过程复制 trace 掩码**

**文件**：`src/process/proc/mod.rs`

```rust
cdata.tracemask.clone_from(&pdata.tracemask);
```

**解释**：
 在创建子进程时，将父进程的 `tracemask` 值拷贝到子进程，实现“追踪设置可继承”的语义。符合题目要求：trace 只影响当前进程及其子进程。

------

**系统调用名称数组与 trait 注册**

**文件**：`src/process/proc/syscall.rs`

```rust
pub static SYSCALL_NAME: [&str; 24] = ["", "fork", "exit", "wait", ..., "trace", "sysinfo"];
fn sys_trace(&mut self) -> SysResult;
```

**解释**：

- 定义了一个全局系统调用名称数组，用于在追踪输出中打印系统调用名字；
- 在 trait 中注册了 `sys_trace()` 系统调用的声明。

------

**实现 trace 系统调用逻辑**

**文件**：`src/process/proc/syscall.rs`

```rust
fn sys_trace(&mut self) -> SysResult {
    let input_mask = self.arg_i32(0);
    if input_mask < 0 {
        Err(())
    } else {
        (*self.data.get_mut()).tracemask = input_mask as usize;
        Ok(0)
    }
}
```

**解释**：
 实现了 `trace(mask)` 的核心逻辑：

- 读取用户传入的参数 `mask`；
- 若合法，则设置到当前进程的 `tracemask` 字段中；
- 返回 0 表示设置成功。

------

#### 实验六：加速系统调用

**添加共享页虚拟地址常量 `USYSCALL`**

**文件路径：** `src/consts/memlayout.rs`

```rust
pub const USYSCALL: ConstAddr = TRAPFRAME.const_sub(PGSIZE);
```

**解释：**
 新增 `USYSCALL` 常量，用于指定一块在用户地址空间可访问的只读共享页面地址。该地址位于 `TRAPFRAME` 前一页，为后续共享只读数据（如 PID）提供映射依据。

------

**在页表中映射 USYSCALL 页**

**文件路径：** `src/mm/pagetable.rs`

```rust
pub fn alloc_proc_pagetable(trapframe: usize, usyspage: usize) -> Option<Box<Self>> {
    ...
    pagetable
        .map_pages(
            VirtAddr::from(USYSCALL),
            PGSIZE,
            PhysAddr::try_from(usyspage).unwrap(),
            PteFlag::R | PteFlag::U,
        )
        .ok()?;
    ...
}
```

**解释：**
 为用户进程的页表添加 `USYSCALL` 到物理页的映射，并设置为只读用户权限。这允许用户态程序无需系统调用即可读取如 PID 等信息，从而加速系统调用。

------

**释放页表时取消 USYSCALL 映射**

**文件路径：** `src/mm/pagetable.rs`

```rust
self.uvm_unmap(USYSCALL.into(), 1, false);
```

**解释：**
 在销毁进程页表时，移除对 USYSCALL 页面的映射，防止悬空映射和潜在资源泄漏。

------

**分配并初始化 UsysPage 页面**

**文件路径：** `src/process/mod.rs`

```rust
pd.up = unsafe { RawSinglePage::try_new_zeroed().ok()? as *mut UsysPage };
(unsafe { &mut *pd.up }).pid = new_pid as u32;

match PageTable::alloc_proc_pagetable(pd.tf as usize, pd.up as usize) {
    ...
}
```

**解释：**
 在创建进程时分配一页用于 `UsysPage` 的内存，并将当前进程的 PID 写入。该页面将映射到用户态，使得用户程序可通过读取共享内存的方式获得进程信息。

------

**更新 ELF 加载路径的页表创建调用**

**文件路径：** `src/process/proc/elf.rs`

```rust
match PageTable::alloc_proc_pagetable(pdata.tf as usize, pdata.up as usize) {
```

**解释：**
 确保在通过 ELF 加载用户程序时也传入 `UsysPage` 指针，使页表初始化函数能正确映射该共享页。

------

**在进程控制块中添加 up 字段**

**文件路径：** `src/process/proc/mod.rs`

```rust
pub up: *mut UsysPage,
```

**解释：**
 在进程的数据结构 `ProcData` 中新增 `up` 字段，用于保存 `UsysPage` 页面的指针，使该页面在整个进程生命周期中可访问并可管理。

------

**释放 UsysPage 页面**

**文件路径：** `src/process/proc/mod.rs`

```rust
let up = self.up;
self.up = ptr::null_mut();
if !up.is_null() {
    unsafe { RawSinglePage::from_raw_and_drop(up as *mut u8); }
}
```

**解释：**
 在进程退出时回收为 `UsysPage` 分配的物理内存，确保无资源泄漏。

------

**定义用户共享结构体 `UsysPage`**

**文件路径：** `src/process/trapframe.rs`

```rust
#[repr(C)]
#[derive(Debug)]
pub struct UsysPage {
    pub pid: u32,
}
```

**解释：**
 定义 `UsysPage` 结构体，该结构用于在共享页面中存放只读信息（当前仅包含 PID），用户程序可以通过读取该结构体以免去一次系统调用。

------

#### 实验七：打印页表

**引入原子布尔类型用于只打印一次页表**

文件路径：`src/mm/pagetable.rs`

```rust
use core::sync::atomic::AtomicBool;
```

**解释**：
 为了控制只在第一次调用 `vm_print` 时打印页表头部信息，使用了 `AtomicBool` 类型的全局标志变量 `INIT_VM_PRINT`，具备线程安全性。

------

**实现页表打印函数 `vm_print()`**

文件路径：`src/mm/pagetable.rs`

```rust
pub fn vm_print(&self, level: usize)
{
    if INIT_VM_PRINT.swap(false, core::sync::atomic::Ordering::Relaxed) {
        println!("page table {:p}", &(self.data));
    }
    for (idx, pte) in self.data.iter().enumerate() {
        if pte.is_valid() {
            if level == 0 {
                println!("..{}: pte {:#x} pa {:p}", idx, pte.data, pte.as_page_table());
                (unsafe { &*pte.as_page_table() }).vm_print(1);
            }
            if level == 1 {
                println!(".. ..{}: pte {:#x} pa {:p}", idx, pte.data, pte.as_page_table());
                (unsafe { &*pte.as_page_table() }).vm_print(2);
            }
            if level == 1 {
                println!(".. .. ..{}: pte {:#x} pa {:p}", idx, pte.data, pte.as_page_table());
            }
        }
    }
}
```

**解释**：
 该函数递归打印多级页表结构，采用缩进标识树的深度（`..`, `.. ..` 等）。其中：

- 顶层页表打印头部；
- 只打印有效的 PTE；
- 每级递归调用自身，逐层深入；
- 缩进由 `level` 决定。

注意：最内层的判断 `if level == 1` 出现了两次，应考虑修正为 `level == 2`。

------

**全局初始化标志**

文件路径：`src/mm/pagetable.rs`

```rust
static INIT_VM_PRINT: AtomicBool = AtomicBool::new(true);
```

**解释**：
 只允许打印页表头部一次，避免多次重复输出 `"page table ..." ` 字样。

------

**系统调用返回前触发页表打印**

文件路径：`src/process/proc/syscall.rs`

```rust
let guard = self.excl.lock();
if guard.pid == 1 {
    let data = self.data.get_mut();
    data.pagetable.as_ref().unwrap().vm_print(0);
}
drop(guard);
```

**解释**：
 在系统调用结束之前检查当前进程是否为 PID 1（即第一个用户进程），如果是，则调用其页表的 `vm_print()` 函数。

- 使用 `lock` 获取排他访问；
- 获取进程页表；
- 调用递归打印；
- `drop(guard)` 手动释放锁，保持良好资源管理。

------

#### 实验八：检测某一页是否被访问过

**添加** **PTE** **的访问位判断与清除函数**

文件路径： `src/mm/pagetable.rs`

```rust
#[inline]
pub fn is_access(&self) -> bool {
    (self.data & (PteFlag::A.bits())) > 0
}

#[inline]
pub fn clear_access(&mut self) {
    self.data &= !PteFlag::A.bits()
}
```

**解释：**
 新增两个方法用于检测和清除页表项中的访问位（Accessed bit）：

- `is_access()` 用于判断该页是否被访问过（读或写）；
- `clear_access()` 在检测之后清除访问位，为下次访问检测提供可能性。

这是实现 `pgaccess` 系统调用的核心，需依赖 PTE 中的 A 位来记录访问状态。

------

**将 `walk_mut` 改为公有以便系统调用访问页表项**

文件路径： `src/mm/pagetable.rs`

```rust
- fn walk_mut(&mut self, va: VirtAddr) -> Option<&mut PageTableEntry> {
+ pub fn walk_mut(&mut self, va: VirtAddr) -> Option<&mut PageTableEntry> {
```

**解释：**
 为了在系统调用 `sys_pgaccess` 中访问用户页表项，需要将原本私有的 `walk_mut()` 方法设为公有（`pub`）。该函数用于获取虚拟地址对应的 PTE 的可变引用，是遍历用户地址空间时的关键接口。

------

**为系统调用表增加 `pgaccess` 调度分支**

文件路径： `src/process/proc/mod.rs`

```rust
+ 22 => self.sys_pgaccess(),
```

**解释：**
 将系统调用号 `22` 映射到对应处理函数 `sys_pgaccess()`，是将用户空间调用正确路由到内核处理逻辑的必要步骤。该修改确保用户可以通过 syscall 机制访问新实现的功能。

------

**在 Syscall trait 中声明 `sys_pgaccess` 接口**

文件路径： `src/process/proc/syscall.rs`

```rust
fn sys_pgaccess(&mut self) -> SysResult;
```

**解释：**
 在 `Syscall` trait 中新增对 `sys_pgaccess` 方法的声明，确保进程结构体 `Proc` 的实现中包含该系统调用接口。这是 Rust trait 系统中统一行为定义的一部分。

------

**实现 `pgaccess` 系统调用主体逻辑**

文件路径： `src/process/proc/syscall.rs`

```rust
fn sys_pgaccess(&mut self) -> SysResult {
    let mut start_va = self.arg_addr(0);
    let page_num = self.arg_i32(1);
    let ret_pa = self.arg_addr(2);
    let mut ret: usize = 0;
    let pgt = self.data.get_mut().pagetable.as_mut().unwrap();
    for i in 0..page_num {
        let pte = pgt.walk_mut(unsafe { VirtAddr::from_raw(start_va) }).unwrap();
        if pte.is_access() {
            ret |= 1 << i;
        }
        pte.clear_access();
        start_va += PGSIZE;
    }
    let _ = pgt.copy_out(&ret as *const usize as *const u8, ret_pa, size_of::<usize>());
    Ok(0)
}
```

**解释：**
 该系统调用的核心功能实现：

- 读取用户传入的起始虚拟地址、页数和返回地址；
- 遍历每一页，对应的 PTE 若访问位为 1，则在结果 bitmask 中设置对应位；
- 每次检测后清除该页的访问位；
- 将 bitmask 结果写回用户空间。

------

#### 实验九：回溯调用栈

**添加 Backtrace 函数**

文件路径: `src/printf.rs`

```rust
pub fn backtrace() {
    let pgt = unsafe { CPU_MANAGER.my_proc().data.get_mut().pagetable.as_mut().unwrap() };
    let mut fp: usize;
    unsafe {
        core::arch::asm!("mv {}, fp", out(reg) fp);
    }
    let mut ra: usize;
    let barrier: usize = (fp + crate::consts::PGSIZE - 1) & !(crate::consts::PGSIZE - 1);
    println!("backtrace:");
    while fp < barrier {
        ra = unsafe { kvm_pa(VirtAddr::from_raw(*((fp - 8) as *const usize))) } as usize;
        println!("0x{:x}", ra);
        fp = unsafe { *((fp - 16) as *const usize) };
    }
}
```

**解释**:
 该部分新增了一个 `backtrace()` 函数，用于回溯内核调用栈并打印出每一帧中的返回地址。利用 RISC-V 的 `s0` 寄存器（即帧指针 `fp`）获取当前函数的栈帧指针，并按照固定偏移读取保存的返回地址和上一层帧指针，逐层回溯。`kvm_pa` 用于虚拟地址转物理地址，`barrier` 限制在单页内栈空间，避免栈外非法访问。

------

**在系统调用中插入回溯**

文件路径: `src/process/proc/syscall.rs`

```rust
crate::printf::backtrace();
```

**解释**:
 将 `backtrace()` 的调用插入至 `sys_sleep` 系统调用的开头，使得每次用户调用 `sleep` 时，内核会打印当前的调用栈信息。这是该实验的测试入口，配合 `bttest` 测试程序使用，用于验证调用栈是否能正确回溯输出。原有错误调用被替换为正确的全局函数路径。

------

#### 实验十：周期性任务调用

**添加 ProcAlarm 结构体以支持报警状态**

文件路径：`src/process/proc/mod.rs`

```rust
pub struct ProcAlarm {
    pub interval: usize,
    pub past_tick: usize,
    pub handler_addr: isize,
    pub alarm_frame: *mut TrapFrame,
    pub handler_called: bool,
}

impl ProcAlarm {
    const fn new() -> Self { ... }

    pub fn cleanup(&mut self) { ... }
}
```

**解释**：
 定义了一个新的结构体 `ProcAlarm`，用于保存每个进程的定时器报警相关信息，包括周期间隔、处理函数地址、处理函数是否调用、保存 TrapFrame 的副本等。`cleanup()` 方法用于资源清理，防止内存泄漏。

------

**为进程添加 alarm 字段**

文件路径：`src/process/proc/mod.rs`

```rust
pub struct Proc {
    ...
    pub alarm: UnsafeCell<ProcAlarm>,
}
impl Proc {
    pub const fn new() -> Self {
        ...
        alarm: UnsafeCell::new(ProcAlarm::new()),
    }
}
```

**解释**：
 在 `Proc` 结构中添加 `alarm` 字段，以存储每个进程的报警配置。使用 `UnsafeCell` 是为了在拥有不可变引用时进行内部可变性修改。

------

**添加两个系统调用：sigalarm 和 sigreturn**

文件路径：`src/process/proc/syscall.rs`

```rust
fn sys_sigalarm(&mut self) -> SysResult {
    let interval = self.arg_i32(0) as usize;
    let handler = self.arg_addr(1) as isize;
    let p = self.alarm.get_mut();
    p.interval = interval;
    p.handler_addr = handler;
    Ok(0)
}

fn sys_sigreturn(&mut self) -> SysResult {
    let pa = self.alarm.get_mut();
    let pd = self.data.get_mut();
    unsafe { core::ptr::copy_nonoverlapping(pa.alarm_frame, pd.tf, 1) };
    pa.handler_called = false;
    Ok(0)
}
```

**解释**：

- `sigalarm`：保存用户传入的 tick 周期和处理函数地址。
- `sigreturn`：恢复中断时保存的 trapframe，使用户进程可以从中断现场继续执行。

------

**在 fork 过程中复制 alarm 状态**

文件路径：`src/process/proc/mod.rs`

```rust
let palarm = self.alarm.get_mut();
let calarm = unsafe { child.alarm.get().as_mut().unwrap() };
...
ptr::copy_nonoverlapping(palarm.alarm_frame, calarm.alarm_frame, 1);
```

**解释**：
 确保 `fork()` 后子进程也能继承父进程的 alarm 状态，包括 `alarm_frame` 内容，保持行为一致。

------

**在 alloc_proc 过程分配 alarm_frame**

文件路径：`src/process/mod.rs`

```rust
let pa = p.alarm.get_mut();
...
pa.alarm_frame = unsafe { RawSinglePage::try_new_zeroed().ok()? as *mut TrapFrame };
```

**解释**：
 为每个进程初始化 `alarm_frame`，用于保存中断时的 trapframe 备份。

------

**在清理过程中释放 alarm_frame**

文件路径：`src/process/mod.rs`

```rust
let child_alarm = unsafe { self.table[i].alarm.get().as_mut().unwrap() };
...
child_alarm.cleanup();
```

**解释**：
 避免 `alarm_frame` 在进程回收时产生内存泄漏。

------

**注册系统调用号**

文件路径：`src/process/proc/mod.rs`

```rust
22 => self.sys_sigalarm(),
23 => self.sys_sigreturn(),
```

**解释**：
 将 `sigalarm` 和 `sigreturn` 添加到系统调用表中，系统调用号为 22 和 23。

------

**trap 处理中注入用户 handler**

文件路径：`src/trap.rs`

```rust
if STARTED.load(Ordering::SeqCst) {
    let pa = unsafe { CPU_MANAGER.my_proc().alarm.get_mut() };
    let pd = unsafe { CPU_MANAGER.my_proc().data.get_mut() };
    if pa.interval > 0 {
        pa.past_tick += 1;
    }
    if (pa.past_tick == pa.interval) && (!pa.handler_called) && (pa.interval > 0) {
        pa.past_tick = 0;
        unsafe { core::ptr::copy_nonoverlapping(pd.tf, pa.alarm_frame, 1) };
        (unsafe {&mut *pd.tf }).epc = pa.handler_addr as usize;
        pa.handler_called = true;
    }
}
```

**解释**：
 在每次定时器中断时，检查是否需要调用 alarm handler。如果是，则备份当前 trapframe 并跳转到用户自定义 handler。设置 `handler_called = true` 防止 re-entry。

------

#### 实验十一：内存懒分配

文件路径：`src/mm/pagetable.rs`

1. 修改 `try_clone` 函数中的错误处理

```rust
return Err(());
```

**解释**：
 修改了 `try_clone` 函数的错误处理方式，原来是使用 `panic!`，现在改为返回 `Err(())`。这种方式避免了程序的崩溃，而是通过返回错误让调用者处理。

------

2. 创建 `null` 变量以避免空指针错误

```rust
let mut null = PageTableEntry { data: 0 };
```

**解释**：
 在 `unmap` 函数中新增了 `null` 变量，确保在没有找到有效页表条目时，能够安全地跳过处理。

------

3. 替代 `unwrap` 以增加空值检查

```rust
let pte_option = unsafe { self.walk_mut( VirtAddr::from_raw(ca)) };
if let Some(inn) = pte_option {
    pte = inn;
}
else {
    return;
}
```

**解释**：
 这段修改用于 `unmap` 函数中，替代原来直接使用 `unwrap()` 的方式，增加了对 `walk_mut` 返回结果的安全处理，避免了潜在的程序崩溃。

------

4. 修改 `uvm_copy` 函数中的错误处理

```rust
return Ok(());
```

**解释**：
 在 `uvm_copy` 函数中，如果在尝试克隆页表条目时失败，现在直接返回 `Ok(())`，防止继续执行不必要的操作。

------

文件路径：`src/process/proc/mod.rs`

1. 注释掉 `uvm_alloc` 调用

```rust
// self.pagetable.as_mut().unwrap().uvm_alloc(old_size, new_size)?;
```

**解释**：
 注释掉了 `uvm_alloc` 调用，这表明开发者正在排查或修改内存分配逻辑，避免在当前上下文中调用该方法。

------

文件路径：`src/register/scause.rs`

1. 增加 `PageFault` 枚举成员

```rust
PageFault,
```

**解释**：
 在 `ScauseType` 枚举中新增了 `PageFault` 成员，用于表示页面错误。这是为了支持页面故障类型的处理。

------

2. 修改 `get_scause` 函数来处理页面故障

```rust
13 => ScauseType::PageFault,
15 => ScauseType::PageFault,
```

**解释**：
 在 `get_scause` 函数中，增加了对 `13` 和 `15` 的处理，这两个值分别代表页面缺失（Page Fault）。这表明程序现在能处理来自硬件的页面故障中断。

------

文件路径：`src/trap.rs`

1. 增加页面故障处理逻辑

```rust
ScauseType::PageFault => {
    //println!("!!");
    let layout = Layout::from_size_align(4096, 4096).expect("Invalid layout");
    // 分配 4KB 的内存空间
    let ptr = GlobalAlloc::alloc(&KERNEL_HEAP, layout) as *mut u8;
    if ptr.is_null() {
        p.killed = true.into();
    }
    p.data.get_mut().pagetable.as_mut().unwrap().map_pages(
        VirtAddr::from_raw(pg_round_down(stval::read())),
        4096,
        PhysAddr::from_raw(ptr as usize),
        PteFlag::R | PteFlag::W | PteFlag::U);
}
```

**解释**：
 在 `user_trap` 函数中增加了处理页面故障的逻辑。如果捕获到页面故障 (`ScauseType::PageFault`)，会分配 4KB 的内存空间，并将其映射到进程的页表中，确保程序能够继续执行。若内存分配失败，则将进程标记为死亡。

------

2. 在 `kerneltrap` 中增加页面故障的接口

```rust
ScauseType::PageFault => {
    
}
```

**解释**：
 在 `kerneltrap` 函数中增加了对页面故障的捕获，虽然具体实现未完善，但为后续处理页面故障留下了接口。

#### 实验十二：优先级调度

1. 系统调用接口

```rust
// 设置当前进程优先级的系统调用
fn sys_setpri(&mut self) -> SysResult {
    // 读取第 0 个系统调用参数（用户传入的新优先级，i32）
    let input_pri = self.arg_i32(0);

    // 检查取值范围：只允许 0..=255
    if input_pri < 0 || input_pri > 255 {
        // 超出范围：给出提示（不修改优先级）
        println!("Priority: 0 - 255");
    } else {
        // 合法：加锁拿到进程的可变引用，写入新的优先级（转为 usize）
        // 注意：lock() 返回的守卫是临时值，语句结束后自动释放锁
        self.excl.lock().priority = input_pri as usize;
    }

    // 主动让出 CPU：让调度器立刻重新评估（若当前优先级被降低，其他更高优先级进程可接管）
    self.yielding();

    // 返回 0 表示调用成功（即使越界提示也返回 0，按你当前语义）
    Ok(0)
}

// 获取当前进程优先级的系统调用
fn sys_getpri(&mut self) -> SysResult {
    // 加锁读取当前进程的优先级（守卫在语句结束时自动释放）
    let pri = self.excl.lock().priority;

    // 将优先级作为返回值带回用户态
    Ok(pri)
}

```

2. 调度函数

```rust
// 从进程表中选择“优先级数值最大”的可运行进程；两阶段：先只读选出候选，再加锁占用，避免借用冲突与竞态
fn alloc_runnable(&mut self) -> Option<&mut Proc> {
    // Phase 1：只读扫描，找出 priority 最大的 RUNNABLE
    let mut best_idx: Option<usize> = None;   // 当前最佳候选在表中的下标
    let mut best_prio: usize = 0;             // 已见到的最高优先级（数值越大优先级越高）

    for (i, p) in self.table.iter().enumerate() { // 只读遍历进程表；用 iter() 而非 iter_mut() 以便后续可变借用
        let guard = p.excl.lock();                 // 短暂加锁读取该进程的状态/优先级
        if matches!(guard.state, ProcState::RUNNABLE) { // 仅考虑 RUNNABLE 的进程
            let prio = guard.priority;             // 读取该进程的优先级
            match best_idx {                       // 与当前最佳候选比较
                None => {
                    best_idx = Some(i);            // 首个候选：记录下标
                    best_prio = prio;              // 记录其优先级
                }
                Some(j) => {
                    // 更高优先级则替换；同优先级时用更小的下标打破平局，保证确定性
                    if prio > best_prio || (prio == best_prio && i < j) {
                        best_idx = Some(i);        // 更新最佳下标
                        best_prio = prio;          // 更新最佳优先级
                    }
                }
            }
        }
        // guard 在此作用域结束自动释放（短持锁，避免长时间占用）
    }

    let idx = best_idx?;                           // 若没有任何 RUNNABLE，直接返回 None

    // Phase 2：二次加锁占用（RUNNABLE→ALLOCATED）
    let p = &mut self.table[idx];                  // 现在对选中的条目做可变借用（不会与上面的 iter() 冲突）
    let mut guard = p.excl.lock();                 // 再次加锁，准备修改其状态
    if matches!(guard.state, ProcState::RUNNABLE) {// 二次确认：防止在两阶段之间状态被他处改变
        guard.state = ProcState::ALLOCATED;        // 从 RUNNABLE 占用出来；稍后 scheduler 会把它设为 RUNNING
        drop(guard);                               // 释放锁（也可交给作用域自动释放）
        return Some(p);                            // 返回被选中的进程可变引用
    } else {
        drop(guard);                               // 候选已不再 RUNNABLE（可能被抢走/睡眠/退出），释放锁
        None                                       // 放弃本次选择；由调用者决定是否重试
    }
}
```
