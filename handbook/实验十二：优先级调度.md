#### 实验十二：优先级调度

**实验背景**

原始 xv6 调度器按“简单轮转（round-robin）”工作：在进程表中寻找 RUNNABLE 进程，依次让它们运行，每个进程获得大致公平的时间片。该策略实现简单、可预测，但无法区分“重要任务”和“普通任务”。优先级调度为每个进程分配一个整数优先级，**数值越大优先级越高**。调度器应始终把 CPU 分配给**就绪队列中优先级最高**的进程；若有多个并列最高，可在它们之间继续做轮转或按到达顺序选择。

**实验内容**

本实验将引导你为 **xv6-rust** 内核加入**基于优先级的进程调度**。完成后，内核会总是选择**当前系统中优先级最高**的可运行（RUNNABLE）进程执行；你还将添加系统调用，允许进程在用户态**设置/查询自身优先级**。

- **实现优先级调度**：修改 xv6-rust 的调度器，使其不再简单轮转，而是始终选择**优先级数值更大**的 RUNNABLE 进程运行。

- **为进程添加优先级字段**：在进程结构中加入 `priority` 字段，所有新建进程使用**0**作为默认优先级（推荐优先级范围为0-255）。

- **新增系统调用 `setpri` / `getpri`**：实现 `setpri(int new_priority)`（设置**当前进程**优先级）与 `getpri()`（返回**当前进程**优先级）。

实现方法

- 进程结构（`Proc`）与调度循环（ `schedule()`）位于 `process/` 模块中。
- 系统调用：在 syscall 分发表中注册编号与处理函数，用户态通过封装/汇编入口触发 ecall。
- 本实验的核心是：给 `Proc` 增加 `priority`，修改调度器“挑选下一个进程”的策略，并新增 `setpri`/`getpri`。

**实验提示**

1) 在进程结构中加入 `priority` 字段

- 在 `struct ProcExcl`中添加 `priority: usize`。
- 优先级范围建议0 - 255，并在**创建新进程**时初始化，把 `priority` 设为默认值，建议为 0。

- 确认所有新建进程（init、sh、子进程）都能拿到默认优先级。
- Rust 结构新增字段后，记得更新相应的构造/初始化代码。

------

2) 修改调度器：按优先级选择 RUNNABLE 进程

- 把现有“遇到 RUNNABLE 就选”的轮转逻辑改为“**在所有 RUNNABLE 中挑最高优先级**”

- 在调度循环中扫描进程表：记录**当前看到的最高优先级**及其进程；
- 若存在并列最高，可直接取第一位（简单做法），或在并列者之间做**等优先级的轮转**
- 找到候选后进行上下文切换；若无 RUNNABLE 进程，进入 idle（如 `wfi`）或继续自旋。

- 你可以将“谁来选”的策略下沉到如 `alloc_runnable()` 这样的辅助函数中，使 `scheduler()` 逻辑保持简洁。

------

3) 实现系统调用 `setpri` / `getpri`

- `int setpri(int new_priority)`:
  - 仅作用于**当前调用进程**。
  - 读取旧优先级，检查 `new_priority` 是否在合法范围；合法则写入，不合法则可直接返回旧值或返回错误码（自定）。
  - **建议返回旧优先级**，以便用户态了解变更前的值。
  - **建议行为**：如果该调用**降低了当前进程的优先级**，且系统中存在更高优先级的 RUNNABLE 进程，可在返回前调用 `yield()` 主动让出 CPU，让更高优先级尽快运行
- `int getpri(void)`:
  - 返回当前进程的 `priority`。