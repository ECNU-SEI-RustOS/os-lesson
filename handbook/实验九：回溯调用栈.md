#### 实验九：回溯调用栈

**实验内容与现象**

在调试过程中，**回溯调用栈（Backtrace）** 是一项非常有用的工具。它可以列出从错误发生点向上传递的函数调用栈信息，帮助我们定位程序是如何一步步走到当前出错位置的。

在本实验中，你需要实现一个 `backtrace()` 函数，并将其写在 `src/printf.rs` 中。然后，在 `sys_sleep` 函数中插入对该函数的调用。接着运行用户态测试程序 `bttest`，该程序内部会调用 `sys_sleep`。

如果你的实现正确，程序的输出将类似于以下内容（其中地址可能略有不同）：

```
backtrace:
0x800202f0
0x800220fa
0x80025b32
```

测试完成后，退出 QEMU。在终端中使用如下命令，将这些地址转换为对应的源代码行号（注意根据工具链选择命令）：

```sh
addr2line -e target/riscv64gc-unknown-none-elf/debug/xv6-rust 
0x800202f0
0x800220fa
0x80025b32
Ctrl + D
```

输出应类似如下内容，表示每个调用栈返回地址对应的源文件和行号：

```
/workspaces/xv6-rust/src/process/proc/syscall.rs:289
/workspaces/xv6-rust/src/process/proc/mod.rs:548
/workspaces/xv6-rust/src/trap.rs:86
```

这个功能的实现依赖于编译器在每个函数栈帧中保留的**帧指针（frame pointer）**，它存储了**调用者的栈帧地址**。你需要利用这些帧指针在栈中逐层向上遍历，并打印出每一层栈帧中保存的返回地址（即调用该函数的位置）。

------

**实验提示**

- 编译器会将当前函数的帧指针（frame pointer）保存在寄存器 `s0/fp` 中。为了获取该值，可以使用如下代码：

  ```rust
  let mut fp: usize;
  unsafe{
      core::arch::asm!("mv {}, fp", out(reg) fp);
  }
  ```

  通过内联汇编将寄存器 `fp` 的值提取出来，并返回。你需要在 `backtrace()` 中使用这段代码，以获取当前栈帧的起始地址。

- Rust编译器可能会优化`fp`寄存器，为了能够正确读到该寄存器，请确保`.cargo/config.toml`中的rustflags包含如下参数

  ```
  "-C", "force-frame-pointers=yes",
  ```

- 根据 RISC-V 调用约定：

  - 当前函数的返回地址保存在帧指针偏移 `-8` 的位置；
  - 上一帧的帧指针保存在偏移 `-16` 的位置；
    利用这一布局，可以沿着帧指针向上传递，逐层还原函数调用栈。

- 内核为每个线程分配一页大小的内核栈，地址为页对齐。你需要按页面对其的计算栈的上下边界，用于判断回溯过程何时终止，避免越界访问。

- 当你验证 `backtrace()` 能正确输出函数调用栈后，可以在 `src/printf.rs` 的 `panic()` 函数中加入对 `backtrace()` 的调用。这样在内核 panic 时，系统会自动打印调用栈信息，有助于分析和调试错误原因。

