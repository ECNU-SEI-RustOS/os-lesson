# SEIOS：基于xv6与Rust语言的教学操作系统

## 0 系统架构说明

### 系统内核整体架构

系统内核部分可粗略分割为硬件驱动与内核两部分，整体架构如图所示

<img src="D:\Document\Project\操作系统大赛\图片\屏幕截图 2025-06-27 150415.png" style="zoom: 50%;" />

##### 硬件驱动

- **页表驱动**：基于RISC-V硬件实现页表机制，负责地址翻译
- **中断控制器驱动**：处理和分发来自硬件设备的中断请求
- **通信串口驱动**：提供终端与系统交互的基础通信功能
- **磁盘驱动**：支持系统与磁盘之间的数据交换，实现磁盘I/O操作

---

##### 内核

该模块是内核的核心，抽象硬件驱动功能并通过系统调用提供给用户程序。其包括三个子模块：

1. **内存管理模块**

- **物理内存管理**：实现物理内存页的分配、释放与管理。
- **虚拟内存管理**：负责维护虚拟地址与物理地址之间的映射，提供隔离与安全保障。

2. **进程管理模块**

- **中断处理**：响应外部设备或软件产生的中断请求。
- **进程调度**：实现抢占式优先级调度，采用轮转算法分配时间片。
- **进程控制**：提供进程的创建、终止、阻塞与唤醒等控制功能。
- **进程同步**：支持信号量、互斥锁、条件变量与屏障等同步机制，保障并发安全。

3. **文件系统模块**

- **物理文件系统**：直接与磁盘驱动交互，管理存储介质上的实际数据。
- **虚拟文件系统**：实现文件系统的抽象层，提供统一接口，层次化分为：
  - 硬件层（磁盘设备驱动）
  - 缓存层（提高访问性能）
  - 日志层（保障数据一致性与恢复）
  - 索引节点层（管理文件元数据）
  - 目录层（维护文件树结构）
  - 文件描述符层（管理文件操作句柄）

内核代码树如下所示：

```
├── asm
│   ├── entry.S            // 汇编启动入口代码，设置堆栈并跳转到内核主函数
│   ├── init.c             // 用于生成用户态初始化代码的C语言源文件
│   ├── initcode.S         // 用户初始化程序(init)的汇编代码，嵌入到内核镜像中
│   ├── kernelvec.S        // 内核中断向量表定义，处理中断和异常入口
│   ├── swtch.S            // 上下文切换的汇编实现，保存/恢复CPU状态
│   └── trampoline.S       // 用户态与内核态切换的跳板页代码，含sret指令
├── consts
│   ├── driver.rs          // 驱动模块所用常量，例如设备寄存器基址等
│   ├── fs.rs              // 文件系统相关常量定义，如磁盘块大小等
│   ├── memlayout.rs       // 内核虚拟地址空间布局与物理内存布局定义
│   ├── mod.rs             // consts模块总入口，统一导出子模块
│   ├── param.rs           // 全局系统参数，例如最大进程数、内核栈大小
│   └── riscv.rs           // RISC-V 架构相关常量，例如CSR寄存器号等
├── driver
│   ├── console.rs         // 控制台输出驱动，依赖UART输出
│   ├── mod.rs             // driver模块入口，统一导出各设备驱动
│   ├── uart.rs            // UART串口驱动，实现字符收发
│   └── virtio_disk.rs     // VirtIO磁盘驱动，处理块设备的读写操作
├── fs
│   ├── bio.rs             // 块缓冲区管理，缓存磁盘块读写
│   ├── block.rs           // 磁盘块分配器，管理空闲块
│   ├── file
│   │   ├── mod.rs         // file模块入口，统一导出文件与管道接口
│   │   └── pipe.rs        // 管道文件实现，实现无名管道的读写
│   ├── inode.rs           // 索引节点实现，表示文件的元数据
│   ├── log.rs             // 日志模块，支持原子文件系统操作
│   ├── mod.rs             // fs模块入口，统一导出文件系统各子模块
│   └── superblock.rs      // 超级块结构与加载逻辑，描述文件系统全局信息
├── ld
│   └── kernel.ld          // 链接脚本，控制内核各段的内存布局
├── lib.rs                 // 内核库模块入口，包含通用宏、panic等定义
├── main.rs                // 内核主函数，启动各子系统并进入第一个进程
├── mm
│   ├── addr.rs            // 虚拟地址与物理地址处理工具
│   ├── kalloc.rs          // 内核物理页分配器，实现简单的空闲页管理
│   ├── kvm.rs             // 内核页表初始化与映射操作
│   ├── list.rs            // 链表工具，支持双向链表实现
│   ├── mod.rs             // mm模块入口，统一导出内存管理模块
│   └── pagetable.rs       // 页表实现，包含页表项结构与映射函数
├── plic.rs                // PLIC 外部中断控制器驱动，实现中断使能与查询
├── printf.rs              // 内核 printf 实现，格式化字符串输出函数
├── process
│   ├── context.rs         // 上下文结构体，保存用户进程寄存器状态
│   ├── cpu.rs             // CPU状态与调度器实现，包含每核的调度器状态
│   ├── mod.rs             // process模块入口，导出进程调度与管理功能
│   ├── proc
│   │   ├── elf.rs         // ELF文件加载器，将用户程序加载进内存
│   │   ├── mod.rs         // proc子模块入口，导出进程创建、退出等功能
│   │   └── syscall.rs     // 系统调用处理器，提供用户态系统服务接口
│   └── trapframe.rs       // 陷入帧结构体，保存陷入内核时的用户态上下文
├── register
│   ├── clint.rs           // CLINT 定时中断控制器驱动，管理mtime中断
│   ├── mie.rs             // mie CSR 寄存器访问封装，控制中断使能位
│   ├── mod.rs             // register模块入口，导出CSR访问相关接口
│   ├── mstatus.rs         // mstatus CSR 操作，管理特权级状态
│   ├── satp.rs            // satp CSR 操作，管理页表根指针
│   ├── scause.rs          // scause CSR，分析异常或中断来源
│   ├── sie.rs             // sie CSR 操作，软件中断控制
│   ├── sip.rs             // sip CSR 状态寄存器封装，查询中断状态
│   └── sstatus.rs         // sstatus CSR 操作，管理S模式状态标志
├── rmain.rs               // 多核入口函数，初始化每个CPU的调度器与陷入向量
├── sleeplock.rs           // 睡眠锁实现，适合I/O等待的互斥保护
├── spinlock.rs            // 自旋锁实现，用于短时临界区互斥保护
├── start.rs               // 内核入口函数，启动第一个核的执行流程
└── trap.rs                // 中断与异常处理主逻辑，分派不同的trap类型
```

---

### 内存管理模块

##### 物理内存管理

物理内存管理负责对物理内存进行有效组织和分配，以确保内存使用效率与安全性。其整体架构包括以下内容：

1. **物理内存布局**
   - 以内核代码段末尾为起点，内核数据段后的所有物理内存视作可分配内存池，用于系统和用户程序的动态内存请求。
2. **分页管理机制**
   - 将物理内存分成固定大小的页面，每个页面由链表节点管理。链表用于维护空闲页面的状态，以支持高效的页面分配和回收。
3. **伙伴算法动态分配**
   - 基于分页机制，采用伙伴（Buddy）算法进行动态内存分配。
   - 每个内存块的大小均为2的幂次，每个块拥有一个地址相邻、大小相同的伙伴块。
   - 内存块处于两种状态之一：
     - **空闲状态**：可以被分配。
     - **已分配状态**：正在被系统或用户程序使用。
4. **内存分配逻辑**
   - 请求内存时：
     - 请求的内存大小向上取整为2的幂次。
     - 查找空闲内存块链表，若不存在匹配块，则递归地分割更大的内存块，直到大小合适的空闲块出现。
     - 将匹配的内存块标记为已分配状态并提供给请求方。
   - 释放内存时：
     - 内存释放后递归检查伙伴块的状态，若伙伴块也为空闲状态，则将其合并为更大的空闲块，循环执行直至无法再合并。
5. **Rust 标准库兼容性**
   - 实现 Rust `alloc` 库中的 `GlobalAlloc` 接口，提供通用的内存分配（`alloc`）和释放（`dealloc`）函数。
   - 借助 Rust 标准库中的数据结构，提升内核与用户程序的开发效率及内存安全性。

---

##### 虚拟内存管理

<img src="D:\Document\Project\操作系统大赛\图片\屏幕截图 2025-06-27 151922.png" style="zoom: 50%;" />

虚拟内存管理模块的目标是通过页表机制将虚拟地址空间有效映射到物理内存空间，实现进程隔离和内存保护。虚拟内存的映射方案如图所示。具体结构包括：

1. **内核与用户虚拟内存空间**
   - 内核与用户进程各自拥有独立的虚拟内存地址空间，通过页表映射到物理内存。
2. **内核页表布局**
   - **上下文切换页（位于虚拟地址空间顶部）**
     - 供进程上下文切换使用，允许不同进程在相同虚拟地址保存和恢复上下文信息，以简化上下文切换流程。
   - **进程内核栈区域**
     - 位于上下文切换页之下，专为每个进程的内核线程提供独立的内核栈空间，保证用户线程与内核线程数据的有效隔离，避免相互干扰。
   - **内核代码与数据映射区域**
     - 对内核自身代码和数据的直接映射，使得内核能够高效访问内存。
3. **设备寄存器地址映射**
   - 设备寄存器以特定的内存地址形式被访问，这些地址并不位于标准物理内存范围内。
   - 本架构采用**直接映射**方案，将设备寄存器的物理地址直接映射到内核页表中虚拟地址相同的位置，以方便内核访问硬件设备。
4. **页表管理与数据传递**
   - 页表管理模块负责不同虚拟地址空间之间的映射管理，提供高效的数据传递和共享机制，确保内存隔离的同时支持必要的通信。

---

### 进程管理模块

##### 中断处理机制

中断处理机制负责接收并统一处理多种中断源的请求，处理流程如图所示，具体设计如下：

<img src="D:\Document\Project\操作系统大赛\图片\屏幕截图 2025-06-27 152741.png" style="zoom:50%;" />

1. **支持的中断源**
   - **外部中断**（PLIC控制）：
     - 通信串口（UART）
     - 磁盘设备（基于VIRTIO接口）
   - **本地中断**（CLINT控制）：
     - 定时器（TIMER）
     - 环境调用（ECALL）
2. **中断分发逻辑**
   - 所有中断均由统一的中断处理函数进行捕获处理。
   - 通过Rust的`match`表达式实现对不同中断原因的模式匹配，将对应的中断请求转发到指定模块（如进程调度模块或设备驱动模块）。
   - 使用match表达式的通配符处理所有未明确定义的情况，统一输出警告信息以保证确定性与安全性。

---

##### 进程调度机制

进程调度器负责不同进程之间的上下文切换，切换的流程如图所示，其设计如下：

<img src="D:\Document\Project\操作系统大赛\图片\屏幕截图 2025-06-27 152855.png" style="zoom: 50%;" />

1. **线程模型**
   - 每个进程包含两个线程：
     - **用户线程**：运行在RISC-V的用户模式（U-mode），每个用户线程拥有独立的页表。
     - **内核线程**：运行在RISC-V的内核模式（S-mode），共享相同内核页表但使用独立的内核栈。
2. **调度过程**
   - 进程调度触发条件包括：
     - 时间片耗尽
     - 进程主动放弃CPU
     - 进程等待资源进入睡眠状态
   - 以进程A切换到进程B为例，调度过程为：
     1. 保存进程A用户线程上下文，切换至A的内核线程。
     2. 保存进程A内核线程上下文，切换到调度器上下文。
     3. 调度器选择下一个运行的进程B。
     4. 加载进程B内核线程上下文。
     5. 最终恢复进程B用户线程上下文，完成一次完整的上下文切换。
3. **多核支持与并发安全**
   - 所有CPU核心共享一个全局进程队列，调度器需访问该队列。
   - 利用Rust的所有权机制与智能指针（如`Arc<Mutex<T>>`），确保每个核心在访问进程队列前必须获取独占的写权限，以避免数据竞争和并发错误。

---

##### 进程控制机制

进程控制机制负责管理进程生命周期中的状态转换，确保操作系统运行效率最大化，进程状态切换如图所示，具体包括：

<img src="D:\Document\Project\操作系统大赛\图片\屏幕截图 2025-06-27 160214.png" style="zoom:50%;" />

1. **进程状态定义**
   - **空闲状态（Idle）**：系统启动时所有进程的初始状态。
   - **就绪状态（Ready）**：等待CPU执行。
   - **运行状态（Running）**：占有CPU进行运行。
   - **睡眠状态（Sleeping）**：等待资源就绪（如锁、磁盘I/O、串口输入等）。
   - **僵尸状态（Zombie）**：进程终止后，尚未被父进程回收资源。
2. **进程生命周期管理**
   - 系统初始化完成后，启动**init进程**用于回收孤儿进程资源。
   - 创建进程（`fork`调用）时：
     - 将父进程页表和物理页面复制给子进程。
     - 子进程进入**就绪状态**。
   - 进程执行过程中：
     - 如果时间片耗尽或主动让出CPU，则返回**就绪状态**。
     - 若等待资源则进入**睡眠状态**，直到资源就绪再返回就绪状态。
   - 进程终止（`exit`调用）后：
     - 进入**僵尸状态**。
     - 父进程负责回收其僵尸子进程资源。
     - 若父进程已终止，则父进程被设置为**init进程**。
3. **进程控制块（PCB）实现**
   - 使用Rust中的`Option`枚举封装进程控制块指针：
     - 若父进程不存在（如已退出），访问PCB将返回`Option::None`。
     - 强制程序员显式处理进程不存在的情况，避免空指针引用导致的安全问题。

---

##### 进程同步机制

进程同步机制使用锁来保护临界区，避免数据竞争问题，包含两种类型的锁：

1. **自旋锁（Spinlock）**
   - 基于RISC-V架构提供的原子指令`amoswap`实现。
   - 使用Rust标准库`core::sync::atomic::AtomicBool`提供封装，简单实现自旋锁的加锁和释放。
2. **睡眠锁（Sleeplock）**
   - 在自旋锁的基础上，为了防止CPU资源浪费和死锁问题，设计了睡眠锁机制。
   - 睡眠锁申请过程：
     1. 若锁已被占用，申请锁的进程释放所有已持有的锁并进入睡眠状态。
     2. 锁被释放时，所有等待此锁的睡眠进程被唤醒，并重新尝试获取锁和恢复执行。
   - 保证了高效的CPU资源利用和并发安全性。

### 文件系统模块

文件系统由物理文件系统与虚拟文件系统两部分组成，其结构与交互模式如图所示：

<img src="D:\Document\Project\操作系统大赛\图片\屏幕截图 2025-06-27 160340.png" style="zoom:50%;" />

##### 物理文件系统

**1. 硬件层**

- 负责与磁盘设备的底层交互：
  - 提供磁盘的初始化、读写操作。
  - 初始化过程将文件系统结构载入磁盘，从最低地址开始分别为：
    - **启动块**：负责磁盘启动。
    - **超级块：记录文件系统元数据。
    - **日志块**：记录磁盘写操作日志。
    - **索引节点块：记录文件及目录的元数据。
    - **位图块**：记录磁盘数据块使用情况。
    - **数据块区域：存储文件实际数据。

------

**2. 缓存层**

- 使用环形队列实现磁盘数据缓存：
  - 采用LRU（最近最少使用）替换算法。
  - 缓存队列由Rust中的`Option`枚举包裹缓存块数组构成。
  - 维护两个可变引用（head 和 tail），分别标记队列中最新和最旧的缓存块，实现高效的LRU驱逐策略。
  - 获取缓存块时：
    - 若有空闲块，直接使用；
    - 若无空闲块，驱逐最旧的未引用缓存块；
    - 若缓存队列满且无法驱逐，则返回`Option::None`。
  - Rust借用检查保证缓存块引用时的数据安全与并发安全。

------

**3. 日志层**

- 日志层用于记录所有磁盘的写操作，确保文件系统操作的一致性与持久性：
  - 系统启动时检查日志块状态，若发现未完成的日志操作（异常关机），则根据日志恢复磁盘数据。
  - 日志写入流程：
    1. 检查日志空间是否足够，若不足则进程睡眠等待；
    2. 进程声明开始文件操作，写入日志区；
    3. 操作完成，声明文件操作结束；
    4. 当无其他未完成文件操作时，日志层执行组提交，将日志内容写入磁盘日志区；
    5. 完整提交后再将数据安装到相应磁盘位置。
  - 若系统异常停止：
    - 如果日志未完整提交，所有更改回滚；
    - 如果日志完整提交，所有更改恢复并持久化。

------

##### 虚拟文件系统

虚拟文件系统基于物理文件系统提供的接口，为应用程序提供统一抽象接口。

**1. 索引节点层**

<img src="D:\Document\Project\操作系统大赛\图片\屏幕截图 2025-06-27 160611.png" style="zoom:50%;" />

- 使用索引节点（Inode）存储文件和目录的元数据信息，索引节点的具体结构如图所示，包括：
  - 文件类型（普通文件或目录）；
  - 磁盘设备号（文件所在磁盘设备位置）；
  - 链接数量（文件被链接的目录个数）；
  - 文件大小（文件占用磁盘块数）；
  - 直接块地址与间接块地址：
    - **直接块地址**：直接存储文件数据块地址，适合小文件快速读取；
    - **间接块地址**：存储指向数据块地址的指针，需要两次磁盘访问，支持较大的文件。
- 采用Rust所有权模型：
  - 每个进程获取索引节点拷贝，拥有独立所有权；
  - 在更新索引节点时，进程必须获取对应索引节点锁以保证并发安全。

------

**2. 目录层**

- 使用树状结构管理文件与目录：
  - 通过解析输入的目录字符串，目录层准确定位目标索引节点；
  - 提供目录查找与定位功能，使文件系统结构清晰直观。

------

**3. 文件描述符层**

- 提供文件访问的最高层抽象：
  - 每个进程维护一个数组记录已打开文件的索引节点引用；
  - 使用数组编号访问对应文件，提供统一的读写接口。
- 特殊设计——设备抽象：
  - 将设备（如串口）抽象为文件进行访问，提供统一的读写接口；
  - 设备初始化时将读写函数注册到系统设备列表；
  - 进程读写文件描述符时：
    - 若目标为设备，调用设备的读写函数；
    - 若目标为普通文件，调用普通文件读写函数。

## 1 操作系统接口

操作系统的工作是在多个程序之间共享一台计算机，并提供一套比硬件单独支持更有用的服务。操作系统管理和抽象低级硬件，因此，例如，文字处理程序不需要关心使用的何种磁盘硬件。操作系统在多个程序之间共享硬件，使它们能同时运行（或看起来是同时运行）。最后，操作系统为程序提供了可控的交互方式，使它们能够共享数据或共同工作。

操作系统通过接口为用户程序提供服务。设计一个好的接口很困难的。一方面，我们希望接口是简单而单一的，因为这样更容易得到正确的实现。另一方面，我们可能会想为应用程序提供许多复杂的功能。解决这种矛盾的诀窍是设计出依靠一些机制的接口，这些机制可以通过组合提高通用性（如管道）。

本书用一个单一的操作系统作为具体的例子来说明操作系统的概念。该操作系统xv6提供了Ken Thompson和Dennis Ritchie的Unix操作系统所介绍的基本接口，同时也模仿了Unix的内部设计。Unix提供了一个单一的接口，其机制结合得很好，提供了惊人的通用性。这种接口非常成功，以至于现代操作系统BSD、Linux、Mac OS X、Solaris，甚至微软Windows都有类似Unix的接口。理解xv6是理解这些系统和许多其它系统的一个良好开端。

如图所示，xv6采用了传统的**内核**形式，内核是一个特殊程序，可以为其他运行进程提供服务。每个正在运行的程序，称为进程，拥有自己的内存，其中包含指令、数据和堆栈。指令实现了程序的计算。数据是计算操作对象。栈允许了函数调用。一台计算机通常有许多进程，但只有一个内核。

​                               <img src="C:\Users\Zenma\AppData\Roaming\Typora\typora-user-images\image-20250806124654055.png" alt="image-20250806124654055" style="zoom:50%;" />

当一个进程需要调用一个内核服务时，它就会调用**系统调用**，这是操作系统接口中的一个调用。系统调用进入内核，内核执行服务并返回。因此，一个进程在用户空间和内核空间中交替执行。

内核使用CPU提供的硬件保护机制来确保在用户空间中执行的每个进程只能访问其自己的内存。内核运行时拥有硬件特权，可以访问这些受到保护的资源;用户程序执行时没有这些特权。当用户程序调用系统调用(接口)时，硬件提高特权级别并开始执行内核中预先安排的函数。

内核提供的系统调用集合是用户程序看到的接口。xv6内核提供了传统Unix内核所提供的服务和系统调用的一个子集。列出了xv6的所有系统调用。

| 函数签名                                                   | 描述                                                         |
| ---------------------------------------------------------- | ------------------------------------------------------------ |
| `fn fork() -> i32`                                         | 创建一个进程，返回子进程的 PID                               |
| `fn exit(status: i32) -> !`                                | 终止当前进程，`status` 传递给 `wait()`；不会返回             |
| `fn kill(pid: i32) -> i32`                                 | 终止给定 PID 的进程；成功返回 0，失败返回 -1                 |
| `fn getpid() -> i32`                                       | 返回当前进程的 PID                                           |
| `fn sleep(ticks: i32) -> i32`                              | 睡眠 `ticks` 个时钟周期                                      |
| `fn exec(file: *const u8, argv: *const *const u8) -> i32`  | 通过给定参数加载并执行一个文件；只在错误时返回               |
| `fn sbrk(n: i32) -> *mut u8`                               | 使进程内存增加 `n` 字节，返回新内存的起始地址                |
| `fn write(fd: i32, buf: *const u8, n: i32) -> i32`         | 将 `buf` 中 `n` 字节写入文件描述符；返回 `n`                 |
| `fn read(fd: i32, buf: *mut u8, n: i32) -> i32`            | 从文件描述符中读取 `n` 字节到 `buf`；返回读取字节数，文件结束返回 0 |
| `fn close(fd: i32) -> i32`                                 | 释放一个文件描述符                                           |
| `fn dup(fd: i32) -> i32`                                   | 返回一个新文件描述符，其引用与 `fd` 相同的文件               |
| `fn pipe(p: *mut i32) -> i32`                              | 创建管道，将读/写文件描述符放置在 `p[0]` 和 `p[1]`           |
| `fn chdir(dir: *const u8) -> i32`                          | 改变当前目录                                                 |
| `fn mkdir(dir: *const u8) -> i32`                          | 创建新目录                                                   |
| `fn mknod(file: *const u8, major: i32, minor: i32) -> i32` | 创建新设备文件                                               |
| `fn fstat(fd: i32, st: *mut Stat) -> i32`                  | 将打开的文件的信息放置在 `*st` 中                            |
| `fn stat(file: *const u8, st: *mut Stat) -> i32`           | 将命名文件的信息放置在 `*st` 中                              |
| `fn link(file1: *const u8, file2: *const u8) -> i32`       | 为文件 `file1` 创建一个新的名称 (`file2`)                    |
| `fn unlink(file: *const u8) -> i32`                        | 移除一个文件                                                 |

本章其余部分概述了xv6的服务进程、内存、文件描述符、管道和文件系统，并通过代码片段和讨论shell（Unix的命令行用户接口），以及使用它们。shell对系统调用的使用说明了系统调用是如何被精心设计的。

shell是一个普通的程序，它从用户那里读取命令并执行它们。shell是一个用户程序，而不是内核的一部分，这一事实说明了系统调用接口的强大功能:shell没有什么特别之处。这也意味着外壳很容易更换;因此，现代Unix系统有许多shell可供选择，每个shell都有自己的用户界面和脚本特性。xv6 shell是Unix Bourne shell的一个简单实现。它的实现可以在(user/sh.c:1)找到。

### 1.1 进程与内存

一个xv6进程由用户空间内存（指令、数据和堆栈）和内核私有的进程状态组成。Xv6的进程共享cpu，它透明地切换当前cpu正在执行的进程。当一个进程暂时不使用cpu时，xv6会保存它的CPU寄存器，在下次运行该进程时恢复它们。内核为每个进程关联一个**PID**(进程标识符)。

 可以使用**fork**系统调用创建一个新的进程。**Fork**创建的新进程，称为子进程，其内存内容与调用的进程完全相同，原进程被称为父进程。在父进程和子进程中，fork都会返回。在父进程中，fork返回子进程的PID；在子进程中，fork返回0。例如，考虑以下用C编程语言编写的程序片段。

```rust
let mut pid = fork();
if pid > 0 {
    // 父进程
    println!("parent: child={}", pid);
    pid = wait(None);
    println!("child {} is done", pid);
} else if pid == 0 {
    // 子进程
    println!("child: exiting");
    exit(0);
} else {
    // fork 失败
    println!("fork error");
}
```

**exit**系统调用退出调用进程，并释放资源，如内存和打开的文件。**exit**需要一个整数状态参数，通常0表示成功，1表示失败。**wait**系统调用返回当前进程的一个已退出（或被杀死）的子进程的PID，并将该子进程的退出状态码复制到一个地址，该地址由wait参数提供；如果调用者的子进程都没有退出，则**wait**等待一个子进程退出。如果调用者没有子进程，wait立即返回-1。如果父进程不关心子进程的退出状态，可以传递一个0地址给wait。在上面的例子中，输出为:

```
parent: child=3884
child: exiting
child 3884 is done
```

可能会以任何一种顺序输出，这取决于是父进程还是子进程先执行它的**printf**调用。在子程序退出后，父进程的**wait**返回，父进程执行**printf**。

虽然子进程最初与父进程拥有相同的内存内容，但父进程和子进程是在不同的内存和不同的寄存器中执行的：改变其中一个进程中的变量不会影响另一个进程。例如，当**wait**的返回值存储到父进程的**pid**变量中时，并不会改变子进程中的变量**pid**。子进程中的**pid**值仍然为零。

**exec**系统调用使用新内存映像来替换进程的内存， 新内存映像从文件系统中的文件中进行读取。这个文件必须有特定的格式，它指定了文件中哪部分存放指令，哪部分是数据，在哪条指令开始，等等。xv6使用ELF格式，第3章将详细讨论。当**exec**成功时，它并不返回到调用程序；相反，从文件中加载的指令在ELF头声明的入口点开始执行。**exec**需要两个参数：包含可执行文件的文件名和一个字符串参数数组。例如：

```rust
let arg0 = b"echo\0";
let arg1 = b"hello\0";

// 注意：argv 最后一个元素必须是 null
let argv: [*const u8; 3] = [
    arg0.as_ptr(),
    arg1.as_ptr(),
    core::ptr::null(),
];

// 调用 exec
let ret = exec(b"/bin/echo\0".as_ptr(), argv.as_ptr());
if ret < 0 {
    println!("exec error");
}
```

上述代码会执行/bin/echo程序，并将argv数组作为参数。大多数程序都会忽略参数数组的第一个元素，也就是程序名称。

xv6 shell使用上述调用来在用户空间运行程序。shell的主结构很简单，参见**main**(user/sh.c:145)。主循环用**getcmd**读取用户的一行输入，然后调用**fork**，创建shell副本。父进程调用wait，而子进程则运行命令。例如，如果用户向shell输入了**echo hello**，那么就会调用**runcmd**，参数为**echo hello**。**runcmd** (user/sh.c:58) 运行实际的命令。对于**echo hello**，它会调用**exec** (user/sh.c:78)。如果**exec**成功，那么子进程将执行echo程序的指令，而不是**runcmd**的。在某些时候，**echo**会调用**exit**，这将使父程序从main(user/sh.c:145)中的**wait**返回。

 你可能会奇怪为什么**fork**和**exec**没有结合在一次调用中，我们后面会看到shell在实现I/O重定向时利用了这种分离的特性。为了避免创建相同进程并立即替换它（使用exec）所带来的浪费，内核通过使用虚拟内存技术（如copy-on-write）来优化这种用例的fork实现（见4.6节）。

Xv6隐式分配大部分用户空间内存：**fork**复制父进程的内存到子进程，**exec**分配足够的内存来容纳可执行文件。一个进程如果在运行时需要更多的内存（可能是为了**malloc**），可以调用sbrk(n)将其数据内存增长n个字节；sbrk返回新内存的位置。

### 1.2 I/O与文件描述符

**文件描述符**是一个小整数，代表一个可由进程读取或写入的内核管理对象。一个进程可以通过打开一个文件、目录、设备，或者通过创建一个管道，或者通过复制一个现有的描述符来获得一个文件描述符。为了简单起见，我们通常将文件描述符所指向的对象称为文件；文件描述符接口将文件、管道和设备之间的差异抽象化，使它们看起来都像字节流。我们把输入和输出称为I/O。

在内部，xv6内核为每一个进程单独维护一个以文件描述符为索引的表，因此每个进程都有一个从0开始的文件描述符私有空间。按照约定，一个进程从文件描述符0(标准输入)读取数据，向文件描述符1(标准输出)写入输出，向文件描述符2(标准错误)写入错误信息。正如我们将看到的那样，shell利用这个约定来实现I/O重定向和管道。shell确保自己总是有三个文件描述符打开（user/sh.c:151），这些文件描述符默认是控制台的文件描述符。

**read**/**write**系统调用可以从文件描述符指向的文件读写数据。调用**read(fd, buf, n)**从文件描述符**fd**中读取不超过**n**个字节的数据，将它们复制到**buf**中，并返回读取的字节数。每个引用文件的文件描述符都有一个与之相关的偏移量。读取从当前文件偏移量中读取数据，然后按读取的字节数推进偏移量，随后的读取将返回上次读取之后的数据。当没有更多的字节可读时，读返回零，表示文件的结束。

**write(fd, buf, n)**表示将**buf**中的**n**个字节写入文件描述符**fd**中，并返回写入的字节数。若写入字节数小于n则该次写入发生错误。和**read**一样，**write**在当前文件偏移量处写入数据，然后按写入的字节数将偏移量向前推进：每次写入都从上一次写入的地方开始。

下面的程序片段(程序**cat**的核心代码)将数据从其标准输入复制到其标准输出。如果出现错误，它会向标准错误写入一条消息。

```rust
let mut buf = [0u8; 512];
loop {
    let n = read(0, &mut buf);
    if n == 0 {
        break; // EOF
    }
    if n < 0 {
        eprintln!("read error");
        exit(1);
    }
    if write(1, &buf[..n as usize]) != n {
        eprintln!("write error");
        exit(1);
    }
}
```

在这个代码片段中，需要注意的是，**cat**不知道它是从文件、控制台还是管道中读取的。同样，**cat**也不知道它是在打印到控制台、文件还是其他什么地方。文件描述符的使用和0代表输入，1代表输出的约定，使得**cat**可以很容易实现。

**close**系统调用会释放一个文件描述符，使它可以被以后的**open**、**pipe**或**dup**系统调用所重用（见下文）。新分配的文件描述符总是当前进程中最小的未使用描述符。

文件描述符和**fork**相互作用，使I/O重定向易于实现。**Fork**将父进程的文件描述符表和它的内存一起复制，这样子进程开始时打开的文件和父进程完全一样。系统调用**exec**替换调用进程的内存，但会保留文件描述符表。这种行为允许shell通过**fork**实现I/O重定向，在子进程中重新打开所选的文件描述符，然后调用**exec**运行新程序。下面是shell运行**cat < input.txt**命令的简化版代码。

```rust
let argv = ["cat\0", core::ptr::null::<u8>()];

if fork() == 0 {
    // 子进程
    close(0); // 释放标准输入文件描述符
    open("input.txt\0", O_RDONLY); // 打开文件，占用 fd 0

    // exec 第一个参数是程序名，第二个是 argv 数组
    exec(argv[0], &argv);
}
```

在子进程关闭文件描述符0后，**open**保证对新打开的**input.txt**使用该文件描述符0。因为此时0将是最小的可用文件描述符。然后**Cat**执行时，文件描述符0（标准输入）引用**input.txt**。这不会改变父进程的文件描述符，它只会修改子进程的描述符。

xv6 shell中的I/O重定向代码正是以这种方式工作的（user/sh.c:82）。回想一下shell的代码，shell已经**fork**子shell，**runcmd**将调用**exec**来加载新的程序。

**open**的第二个参数由一组用位表示的标志组成，用来控制**open**的工作。可能的值在文件控制(fcntl)头(kernel/fcntl.h:1-5)中定义。**O_RDONLY,** **O_WRONLY,** **O_RDWR**, **O_CREATE**, 和 **O_TRUNC,** 它们指定open打开文件时的功能，读，写，读和写，如果文件不存在创建文件，将文件截断为零。

现在应该清楚为什么**fork**和**exec**是分开调用的：在这两个调用之间，shell有机会重定向子进程的I/O，而不干扰父进程的I/O设置。我们可以假设一个由**fork**和**exec**组成的系统调用**forkexec**，但是用这种调用来做I/O重定向似乎很笨拙。shell在调用**forkexec**之前修改自己的I/O设置（然后取消这些修改），或者**forkexec**可以将I/O重定向的指令作为参数，或者（最糟糕的方案）每个程序（比如cat）都需要自己做I/O重定向。

虽然**fork**复制了文件描述符表，但每个底层文件的偏移量都是父子共享的。想一想下面的代码。

```rust
let pid = fork();
if pid == 0 {
    // 子进程
    let msg = b"hello ";
    write(1, msg.as_ptr() as *const c_void, msg.len());
    _exit(0);
} else {
    // 父进程
    wait(core::ptr::null_mut());
    let msg = b"world\n";
    write(1, msg.as_ptr() as *const c_void, msg.len());
}
```

在这个片段的最后，文件描述符1所引用的文件将包含数据hello world。父文件中的**write**（由于有了**wait**，只有在子文件完成后才会运行）会从子文件的**write**结束的地方开始。这种行为有助于从shell命令的序列中产生有序的输出，比如**(echo hello; echo world) >output.txt**。

**dup**系统调用复制一个现有的文件描述符，返回一个新的描述符，它指向同一个底层I/O对象。两个文件描述符共享一个偏移量，就像被**fork**复制的文件描述符一样。这是将hello world写进文件的另一种方法。

```c
fd = dup(1);
write(1, "hello ", 6);
write(fd, "world\n", 6);
```

如果两个文件描述符是通过一系列的**fork**和**dup**调用从同一个原始文件描述符衍生出来的，那么这两个文件描述符共享一个偏移量。否则，文件描述符不共享偏移量，即使它们是由同一个文件的打开调用产生的。**Dup**允许shell实现这样的命令：l**s existing-file non-existing-file > tmp1 2>&1**。2>&1表示2是1的复制品（**dup(1)**），即重定向错误信息到标准输出，已存在文件的名称和不存在文件的错误信息都会显示在文件tmp1中。xv6 shell不支持错误文件描述符的I/O重定向，但现在你知道如何实现它了。

文件描述符是一个强大的抽象，因为它们隐藏了它们连接的细节：一个向文件描述符1写入的进程可能是在向一个文件、控制台等设备或向一个管道写入。

### 1.3 管道

**管道**是一个小的内核缓冲区，作为一对文件描述符暴露给进程，一个用于读，一个用于写。将数据写入管道的一端就可以从管道的另一端读取数据。管道为进程提供了一种通信方式。

下面的示例代码运行程序wc，标准输入连接到管道的读取端。

```c
    int p[2];
    char *argv[2];
    argv[0] = "wc"; 
    argv[1] = 0;
    pipe(p);
    if (fork() == 0)
    {
        close(0);  // 释放文件描述符0
        dup(p[0]); // 复制一个p[0](管道读端)，此时文件描述符0（标准输入）也引用管道读端，故改变了标准输入。
        close(p[0]);
        close(p[1]);
        exec("/bin/wc", argv); // wc 从标准输入读取数据，并写入到参数中的每// 一个文件
    }
    else
    {
        close(p[0]);
        write(p[1], "hello world\n", 12);
        close(p[1]);
    }
```

程序调用**pipe**，创建一个新的管道，并将读写文件描述符记录在数组**p**中，经过**fork**后，父进程和子进程的文件描述符都指向管道。子进程调用**close**和**dup**使文件描述符0引用管道的读端，并关闭p中的文件描述符，并调用**exec**运行**wc**。当**wc**从其标准输入端读取时，它将从管道中读取。父进程关闭管道的读端，向管道写入，然后关闭写端。

如果没有数据可用，管道上的**read**会等待数据被写入，或者等待所有指向写端的文件描述符被关闭；在后一种情况下，读将返回0，就像数据文件的结束一样。事实上，如果没有数据写入，读会无限阻塞，直到新数据不可能到达为止（写端被关闭），这也是子进程在执行上面的**wc**之前关闭管道的写端很重要的一个原因：如果wc的一个文件描述符仍然引用了管道的写端，那么**wc**将永远看不到文件的关闭（被自己阻塞）。

xv6的shell实现了管道，如**grep fork sh.c | wc -l**，shell的实现类似于上面的代码（user/sh.c:100）。执行shell的子进程创建一个管道来连接管道的左端和右端（去看源码，不看难懂）。然后，它在管道左端（写入端）调用**fork**和**runcmd**，在右端（读取端）调用fork和runcmd，并等待两者的完成[[1\]](#_ftn1)。管道的右端（读取端）可以是一个命令，也可以是包含管道的多个命令（例如，**a | b | c**），它又会分叉为两个新的子进程（一个是**b**，一个是**c**）。因此，shell可以创建一棵进程树。这棵树的叶子是命令，内部（非叶子）节点是等待左右子进程完成的进程。

原则上，我们可以让内部节点（非叶节点）运行管道的左端，但这样的实现会更加复杂。考虑只做以下修改：修改sh.c，使其不为**runcmd(p->left)**  fork进程，直接递归运行**runcmd(p->left)**。像这样，**echo hi | wc**不会产生输出，因为当**echo hi**在**runcmd**中退出时，内部进程会退出，而不会调用**fork**来运行管道的右端。这种不正确的行为可以通过不在runcmd中为内部进程调用**exit**来修正，但是这种修正会使代码变得复杂：**runcmd**需要知道该进程是否是内部进程（非叶节点）。当不为**runcmd(p->right)**  **fork**进程时，也会出现复杂的情况。像这样的修改，**sleep 10 | echo hi**就会立即打印出hi，而不是10秒后，因为**echo**会立即运行并退出，而不是等待**sleep**结束。由于sh.c的目标是尽可能的简单，所以它并没有试图避免创建内部进程。

管道似乎没有比临时文件拥有更多的功能：

```
echo hello world | wc
```

不使用管道：

```
echo hello world >/tmp/xyz; wc </tmp/xyz
```

在这种情况下，管道比临时文件至少有四个优势。首先，管道会自动清理自己；如果是文件重定向，shell在完成后必须小心翼翼地删除/tmp/xyz。第二，管道可以传递任意长的数据流，而文件重定向则需要磁盘上有足够的空闲空间来存储所有数据。第三，管道可以分阶段的并行执行，而文件方式则需要在第二个程序开始之前完成第一个程序。第四，如果你要实现进程间的通信，管道阻塞读写比文件的非阻塞语义更有效率。

### 1.4 文件系统

xv6 文件系统包含了数据文件（拥有字节数组）和目录（拥有对数据文件和其他目录的命名引用）。这些目录形成一棵树，从一个被称为根目录的特殊目录开始。像**/a/b/c**这样的路径指的是根目录**/**中的**a**目录中的**b**目录中的名为**c**的文件或目录。不以**/**开头的路径是相对于调用进程的当前目录进行计算其绝对位置的，可以通过**chdir**系统调用来改变进程的当前目录。下面两个**open**打开了同一个文件（假设所有涉及的目录都存在）。

```c
chdir("/a");
chdir("b");
open("c", O_RDONLY);
open("/a/b/c", O_RDONLY);
```

前两行将进程的当前目录改为**/a/b**；后面两行既不引用也不改变进程的当前目录。

有一些系统调用来可以创建新的文件和目录：**mkdir**创建一个新的目录，用**O_CREATE**标志创建并打开一个新的数据文件，以及**mknod**创建一个新的设备文件。这个例子说明了这两个系统调用的使用。

```
mkdir("/dir");
fd = open("/dir/file", O_CREATE | O_WRONLY);
close(fd);
mknod("/console", 1, 1);
```

**mknod**创建了一个引用设备的特殊文件。与设备文件相关联的是主要设备号和次要设备号(**mknod**的两个参数)，它们唯一地标识一个内核设备。当一个进程打开设备文件后，内核会将系统的读写调用转移到内核设备实现上，而不是将它们传递给文件系统。

文件名称与文件是不同的；底层文件（非磁盘上的文件）被称为inode[[1\]](#_ftn1)，一个inode可以有多个名称，称为链接。每个链接由目录中的一个项组成；该项包含一个文件名和对inode的引用。inode保存着一个文件的***metadata\***（元数据），包括它的类型（文件或目录或设备），它的长度，文件内容在磁盘上的位置，以及文件的链接数量。

**fstat**系统调用从文件描述符引用的inode中检索信息。它定义在**stat.h** (kernel/stat.h)的 **stat** 结构中：

```
#define T_DIR 1    // Directory
#define T_FILE 2   // File
#define T_DEVICE 3 // Device
    struct stat
    {
        int dev;     // File system’s disk device
        uint ino;    // Inode number
        short type;  // Type of file
        short nlink; // Number of links to file
        uint64 size; // Size of file in bytes
    };

```

 **link**系统调用创建了一个引用了同一个inode的文件（文件名）。下面的片段创建了引用了同一个inode两个文件a和b。

```
    open("a", O_CREATE | O_WRONLY);
    link("a", "b");

```

读写a与读写b是一样的，每个inode都有一个唯一的inode号来标识。经过上面的代码序列后，可以通过检查fstat的结果来确定a和b指的是同一个底层内容：两者将返回相同的inode号（**ino**），并且nlink计数为2。

**unlink**系统调用会从文件系统中删除一个文件名。只有当文件的链接数为零且没有文件描述符引用它时，文件的inode和存放其内容的磁盘空间才会被释放。

```
  unlink("a");
```

上面这行代码会删除a，此时只有b会引用inode。

```
  fd = open("/tmp/xyz", O_CREATE | O_RDWR);

  unlink("/tmp/xyz");
```

这段代码是创建一个临时文件的一种惯用方式，它创建了一个无名称inode，故会在进程关闭**fd**或者退出时删除文件。

Unix提供了shell可调用的文件操作程序，作为用户级程序，例如**mkdir**、**ln**和**rm**。这种设计允许任何人通过添加新的用户级程序来扩展命令行接口。现在看来，这个设计似乎是显而易见的，但在Unix时期设计的其他系统通常将这类命令内置到shell中（并将shell内置到内核中）。

### 1.5 真实世界的情况

Unix将标准文件描述符、管道和方便的shell语法结合起来进行操作，是编写通用可重用程序的一大进步。这个想法引发了一种软件工具文化，这也是Unix强大和流行的主要原因，而shell是第一种所谓的脚本语言。Unix系统调用接口今天仍然存在于BSD、Linux和Mac OS X等系统中。

Xv6 并不符合 POSIX 标准：它缺少许多系统调用（包括基本的系统调用，如 **lseek**），而且它提供的许多系统调用与标准不同。我们对xv6的主要目标是简单明了，同时提供一个简单的类似UNIX的系统调用接口。一些人已经添加了一些系统调用和一个简单的C库扩展了xv6，以便运行基本的Unix程序。然而，现代内核比xv6提供了更多的系统调用和更多种类的内核服务。例如，它们支持网络、窗口系统、用户级线程、许多设备的驱动程序等等。现代内核不断快速发展，并提供了许多超越POSIX的功能。

Unix用一套文件名和文件描述符接口统一了对多种类型资源（文件、目录和设备）的访问。这个思想可以扩展到更多种类的资源，一个很好的例子是Plan 9[13]，它把资源就是文件的概念应用到网络、图形等方面。然而，大多数Unix衍生的操作系统都没有遵循这一路线。

文件系统和文件描述符已经是强大的抽象。即便如此，操作系统接口还有其他模式。Multics是Unix的前身，它以一种使文件存储看起来像内存的方式抽象了文件存储，产生了一种截然不同的接口。Multics设计的复杂性直接影响了Unix的设计者，他们试图建立一些更简单的东西。

Xv6没有用户系统；用Unix的术语来说，所有的xv6进程都以root身份运行。

本书研究的是xv6如何实现其类似Unix的接口，但其思想和概念不仅仅适用于Unix。任何操作系统都必须将进程复用到底层硬件上，将进程相互隔离，并提供受控进程间通信的机制。在学习了xv6之后，您应该能够研究其他更复杂的操作系统，并在这些系统中看到xv6的基本概念。

## 2 操作系统的组织

操作系统的一个关键要求是同时支持几个活动。例如，使用第1章中描述的系统调用接口，一个进程可以用**fork**创建新进程。操作系统必须在这些进程之间分时共享计算机的资源。例如，即使进程的数量多于硬件CPU的数量，操作系统也必须保证所有的进程都有机会执行。操作系统还必须安排进程之间的隔离。也就是说，如果一个进程出现了bug并发生了故障，不应该影响不依赖bug进程的进程。然而，隔离性太强了也不可取，因为进程间可能需要进行交互，例如管道。因此，一个操作系统必须满足三个要求：多路复用、隔离和交互。

本章概述了如何组织操作系统来实现这三个要求。现实中有很多方法，但本文主要介绍以宏内核[[1\]](#_ftn1)为中心的主流设计，很多Unix操作系统都采用这种设计。本章还介绍了xv6进程的概述，xv6进程是xv6中的隔离单元，以及xv6启动时第一个进程的创建。

Xv6运行在多核[[2\]](#_ftn2)RISC-V微处理器上，它的许多底层功能（例如，它的进程实现）是RISC-V所特有的。RISC-V是一个64位的CPU，xv6是用 "LP64 "C语言编写的，这意味着C编程语言中的long(L)和指针(P)是64位的，但int是32位的。本书假定读者在某种架构上做过一点机器级的编程，并懂一些RISC-V特有的思想。RISC-V有用的参考资料是 "The RISC-V Reader,An Open Architecture Attlas"［12］。用户级ISA[2]和特权架构[1]是官方规范。

一台完整的计算机中的CPU周围都是硬件，其中大部分是I/O接口的形式。Xv6编写的代码是基于通过"-machine virt "选项的qemu。这包括RAM、包含启动代码的ROM、与用户键盘/屏幕的串行连接以及用于存储的磁盘。

### 2.1 物理资源抽象化

遇到一个操作系统，人们可能会问的第一个问题是为什么需要它呢？答案是，我们可以把图1.2中的系统调用作为一个库来实现，应用程序与之连接。在这个想法中，每个应用程序可以根据自己的需要定制自己的库。应用程序可以直接与硬件资源进行交互，并以最适合应用程序的方式使用这些资源（例如，实现高性能）。一些用于嵌入式设备或实时系统的操作系统就是以这种方式组织的。

这种系统库方式的缺点是，如果有多个应用程序在运行，这些应用程序必须正确执行。例如，每个应用程序必须定期放弃CPU，以便其他应用程序能够运行。如果所有的应用程序都相互信任并且没有bug，这样的***cooperative\***分时方案可能是OK的。更典型的情况是，应用程序之间互不信任，并且有bug，所以人们通常希望比***cooperative\***方案提供更强的隔离性。

为了实现强隔离，禁止应用程序直接访问敏感的硬件资源，而将资源抽象为服务是很有帮助的。例如，Unix应用程序只通过文件系统的**open**、**read**、**write**和**close**系统调用与文件系统进行交互，而不是直接读写磁盘。这为应用程序带来了路径名的便利，而且它允许操作系统（作为接口的实现者）管理磁盘。即使不考虑隔离问题，那些有意交互的程序（或者只是希望互不干扰）很可能会发现文件系统是一个比直接使用磁盘更方便的抽象。

同样，Unix在进程之间透明地切换硬件CPU，必要时保存和恢复寄存器状态，这样应用程序就不必意识到时间共享。这种透明性允许操作系统共享CPU，即使一些应用程序处于无限循环中。

另一个例子是，Unix进程使用**exec**来建立它们的内存映像，而不是直接与物理内存交互。这使得操作系统可以决定将进程放在内存的什么位置；如果内存紧张，操作系统甚至可能将进程的部分数据存储在磁盘上。**Exec**还允许用户将可执行文件储存在文件系统中。

Unix进程之间的许多形式的交互都是通过文件描述符进行的。文件描述符不仅可以抽象出许多细节（例如，管道或文件中的数据存储在哪里），而且它们的定义方式也可以简化交互。例如，如果管道中的一个应用程序崩溃了，内核就会为管道中的另一个进程产生一个文件结束信号。

图1.2中的系统调用接口经过精心设计，既为程序员提供了便利，又提供了强隔离的可能。Unix接口并不是抽象资源的唯一方式，但事实证明它是一种非常好的方式。

### 2.2 用户模式，监管模式以及系统调用

强隔离要求应用程序和操作系统之间有一个分界线。如果应用程序发生错误，我们不希望操作系统崩溃，也不希望其他应用程序崩溃。相反，操作系统应该能够清理崩溃的应用程序并继续运行其他应用程序。为了实现强隔离，操作系统必须安排应用程序不能修改（甚至不能读取）操作系统的数据结构和指令，应用程序不能访问其他进程的内存。

CPU提供了强隔离的硬件支持。例如，RISC-V有三种模式，CPU可以执行指令：***机器模式\****、**监督者（supervisor）模式***和***用户模式\***。在机器模式下执行的指令具有完全的权限，一个CPU在机器模式下启动。机器模式主要用于配置计算机。Xv6会在机器模式下执行几条指令，然后转为监督者模式。

在***监督者（supervisor）\***模式下，CPU被允许执行特权指令：例如，启用和禁用中断，读写保存页表地址的寄存器等。如果用户模式下的应用程序试图执行一条特权指令，CPU不会执行该指令，而是切换到监督者模式，这样监督者模式的代码就可以终止应用程序，因为它做了不该做的事情。第1章的图1.1说明了这种组织方式。一个应用程序只能执行用户模式的指令（如数字相加等），被称为运行在用户空间，而处于监督者模式的软件也可以执行特权指令，被称为运行在内核空间。运行在内核空间（或监督者模式）的软件称为内核。

一个应用程序如果要调用内核函数（如xv6中的读系统调用），必须过渡到内核。CPU提供了一个特殊的指令，可以将CPU从用户模式切换到监督模式，并在内核指定的入口处进入内核。(RISC-V为此提供了ecall指令。)一旦CPU切换到监督者模式，内核就可以验证系统调用的参数，决定是否允许应用程序执行请求的操作，然后拒绝或执行该操作。内核控制监督者模式的入口点是很重要的；如果应用程序可以决定内核的入口点，那么恶意应用程序就能够进入内核，例如，通过跳过参数验证而进入内核。

### 2.3 内核组织

一个关键的设计问题是操作系统的哪一部分应该在监督者模式下运行。一种可能是整个操作系统驻留在内核中，这样所有系统调用的实现都在监督者模式下运行。这种组织方式称为***宏内核\***。

在这种组织方式中，整个操作系统以全硬件权限运行。这种组织方式很方便，因为操作系统设计者不必决定操作系统的哪一部分不需要全硬件权限。此外，操作系统的不同部分更容易合作。例如，一个操作系统可能有一个缓冲区，缓存文件系统和虚拟内存系统共享的数据。

宏内核组织方式的一个缺点是操作系统的不同部分之间的接口通常是复杂的（我们将在本文的其余部分看到），因此操作系统开发者很容易写bug。在宏内核中，一个错误是致命的，因为监督者模式下的错误往往会导致内核崩溃。如果内核崩溃，计算机就会停止工作，因此所有的应用程序也会崩溃。计算机必须重启。

为了降低内核出错的风险，操作系统设计者可以尽量减少在监督者模式下运行的操作系统代码量，而在用户模式下执行操作系统的大部分代码。这种内核组织方式称为**微内核**。

![image-20250808150015084](C:\Users\Zenma\AppData\Roaming\Typora\typora-user-images\image-20250808150015084.png)

图2.1说明了这种微内核设计。在图中，文件系统作为一个用户级进程运行。作为进程运行的OS服务称为服务器。为了让应用程序与文件服务器进行交互，内核提供了一种进程间通信机制，用于从一个用户模式进程向另一个进程发送消息。例如，如果一个像shell这样的应用程序想要读写文件，它就会向文件服务器发送一个消息，并等待响应。

在微内核中，内核接口由一些低级函数组成，用于启动应用程序、发送消息、访问设备硬件等。这种组织方式使得内核相对简单，因为大部分操作系统驻留在用户级服务器中。

xv6和大多数Unix操作系统一样，是以宏内核的形式实现的。因此，xv6内核接口与操作系统接口相对应，内核实现了完整的操作系统。由于xv6不提供很多服务，所以它的内核比一些微内核要小，但从概念上讲xv6是宏内核。

### 2.4 内核代码组织

```
├── asm
│   ├── entry.S            // 汇编启动入口代码，设置堆栈并跳转到内核主函数
│   ├── init.c             // 用于生成用户态初始化代码的C语言源文件
│   ├── initcode.S         // 用户初始化程序(init)的汇编代码，嵌入到内核镜像中
│   ├── kernelvec.S        // 内核中断向量表定义，处理中断和异常入口
│   ├── swtch.S            // 上下文切换的汇编实现，保存/恢复CPU状态
│   └── trampoline.S       // 用户态与内核态切换的跳板页代码，含sret指令
├── consts
│   ├── driver.rs          // 驱动模块所用常量，例如设备寄存器基址等
│   ├── fs.rs              // 文件系统相关常量定义，如磁盘块大小等
│   ├── memlayout.rs       // 内核虚拟地址空间布局与物理内存布局定义
│   ├── mod.rs             // consts模块总入口，统一导出子模块
│   ├── param.rs           // 全局系统参数，例如最大进程数、内核栈大小
│   └── riscv.rs           // RISC-V 架构相关常量，例如CSR寄存器号等
├── driver
│   ├── console.rs         // 控制台输出驱动，依赖UART输出
│   ├── mod.rs             // driver模块入口，统一导出各设备驱动
│   ├── uart.rs            // UART串口驱动，实现字符收发
│   └── virtio_disk.rs     // VirtIO磁盘驱动，处理块设备的读写操作
├── fs
│   ├── bio.rs             // 块缓冲区管理，缓存磁盘块读写
│   ├── block.rs           // 磁盘块分配器，管理空闲块
│   ├── file
│   │   ├── mod.rs         // file模块入口，统一导出文件与管道接口
│   │   └── pipe.rs        // 管道文件实现，实现无名管道的读写
│   ├── inode.rs           // 索引节点实现，表示文件的元数据
│   ├── log.rs             // 日志模块，支持原子文件系统操作
│   ├── mod.rs             // fs模块入口，统一导出文件系统各子模块
│   └── superblock.rs      // 超级块结构与加载逻辑，描述文件系统全局信息
├── ld
│   └── kernel.ld          // 链接脚本，控制内核各段的内存布局
├── lib.rs                 // 内核库模块入口，包含通用宏、panic等定义
├── main.rs                // 内核主函数，启动各子系统并进入第一个进程
├── mm
│   ├── addr.rs            // 虚拟地址与物理地址处理工具
│   ├── kalloc.rs          // 内核物理页分配器，实现简单的空闲页管理
│   ├── kvm.rs             // 内核页表初始化与映射操作
│   ├── list.rs            // 链表工具，支持双向链表实现
│   ├── mod.rs             // mm模块入口，统一导出内存管理模块
│   └── pagetable.rs       // 页表实现，包含页表项结构与映射函数
├── plic.rs                // PLIC 外部中断控制器驱动，实现中断使能与查询
├── printf.rs              // 内核 printf 实现，格式化字符串输出函数
├── process
│   ├── context.rs         // 上下文结构体，保存用户进程寄存器状态
│   ├── cpu.rs             // CPU状态与调度器实现，包含每核的调度器状态
│   ├── mod.rs             // process模块入口，导出进程调度与管理功能
│   ├── proc
│   │   ├── elf.rs         // ELF文件加载器，将用户程序加载进内存
│   │   ├── mod.rs         // proc子模块入口，导出进程创建、退出等功能
│   │   └── syscall.rs     // 系统调用处理器，提供用户态系统服务接口
│   └── trapframe.rs       // 陷入帧结构体，保存陷入内核时的用户态上下文
├── register
│   ├── clint.rs           // CLINT 定时中断控制器驱动，管理mtime中断
│   ├── mie.rs             // mie CSR 寄存器访问封装，控制中断使能位
│   ├── mod.rs             // register模块入口，导出CSR访问相关接口
│   ├── mstatus.rs         // mstatus CSR 操作，管理特权级状态
│   ├── satp.rs            // satp CSR 操作，管理页表根指针
│   ├── scause.rs          // scause CSR，分析异常或中断来源
│   ├── sie.rs             // sie CSR 操作，软件中断控制
│   ├── sip.rs             // sip CSR 状态寄存器封装，查询中断状态
│   └── sstatus.rs         // sstatus CSR 操作，管理S模式状态标志
├── rmain.rs               // 多核入口函数，初始化每个CPU的调度器与陷入向量
├── sleeplock.rs           // 睡眠锁实现，适合I/O等待的互斥保护
├── spinlock.rs            // 自旋锁实现，用于短时临界区互斥保护
├── start.rs               // 内核入口函数，启动第一个核的执行流程
└── trap.rs                // 中断与异常处理主逻辑，分派不同的trap类型
```

### 2.5 进程概述

xv6中的隔离单位（和其他Unix操作系统一样）是一个进程。进程抽象可以防止一个进程破坏或监视另一个进程的内存、CPU、文件描述符等。它还可以防止进程破坏内核，所以进程不能破坏内核的隔离机制。内核必须小心翼翼地实现进程抽象，因为一个错误或恶意的应用程序可能会欺骗内核或硬件做一些不好的事情（例如，规避隔离）。内核用来实现进程的机制包括：用户/监督模式标志、地址空间和线程的时间分割。

为了帮助实施隔离，进程抽象为程序提供了一种错觉，即它有自己的私有机器。一个进程为程序提供了一个看似私有的内存系统，或者说是地址空间，其他进程不能对其进行读写。进程还为程序提供了“私有”的CPU，用来执行程序的指令。

Xv6使用页表（由硬件实现）给每个进程提供自己的地址空间。RISC-V页表将***虚拟地址\***(RISC-V指令操作的地址)转换(或 "映射")为***物理地址\***(CPU芯片发送到主存储器的地址)。

​                               ![image-20250808155735173](C:\Users\Zenma\AppData\Roaming\Typora\typora-user-images\image-20250808155735173.png)

Xv6为每个进程维护一个单独的页表，定义该进程的地址空间。如图2.3所示，进程的用户空间内存的地址空间从虚拟地址0开始的。指令存放在最前面，其次是全局变量，然后是栈，最后是一个堆区（用于**malloc**），进程可以根据需要扩展。有一些因素限制了进程地址空间的最大长度：RISC-V上的指针是64位宽；硬件在页表中查找虚拟地址时只使用低的39位；xv6只使用39位中的38位。因此，最大地址是238-1 = 0x3fffffffff，也就是**MAXVA**（kernel/riscv.h:348）。在地址空间的顶端，xv6保留了一页，用于***trampoline\***和映射进程**trapframe**的页，以便切换到内核，我们将在第4章中解释。

xv6内核为每个进程维护了许多状态，它将这些状态在**proc**结构体中(kernel/proc.h:86)。一个进程最重要的内核状态是它的页表、内核栈和运行状态。我们用**p->xxx**来表示proc结构的元素，例如，**p->pagetable**是指向进程页表的指针。

每个进程都有一个执行线程（简称线程），执行进程的指令。一个线程可以被暂停，然后再恢复。为了在进程之间透明地切换，内核会暂停当前运行的线程，并恢复另一个进程的线程。线程的大部分状态（局部变量、函数调用返回地址）都存储在线程的栈中。每个进程有两个栈：用户栈和内核栈（**p->kstack**）。当进程在执行用户指令时，只有它的用户栈在使用，而它的内核栈是空的。当进程进入内核时（为了系统调用或中断），内核代码在进程的内核栈上执行；当进程在内核中时，它的用户栈仍然包含保存的数据，但不被主动使用。进程的线程在用户栈和内核栈中交替执行。内核栈是独立的（并且受到保护，不受用户代码的影响），所以即使一个进程用户栈被破坏了，内核也可以执行。

一个进程可以通过执行RISC-V **ecall**指令进行系统调用。该指令提高硬件权限级别，并将程序计数器改变为内核定义的入口点。入口点的代码会切换到内核栈，并执行实现系统调用的内核指令。当系统调用完成后，内核切换回用户栈，并通过调用**sret**指令返回用户空间，降低硬件特权级别，恢复执行系统调用前的用户指令。进程的线程可以在内核中阻塞等待I/O，当I/O完成后，再从离开的地方恢复。

**p->state**表示进程是创建、就绪、运行、等待I/O，还是退出。

**p->pagetable**以RISC-V硬件需要的格式保存进程的页表，当进程在用户空间执行时，xv6使分页硬件使用进程的**p->pagetable**。进程的页表也会记录分配给该进程内存的物理页地址。

### 2.6 真实世界的情况

在现实世界中，既可以找到宏内核，也可以找到微内核。许多Unix内核都是宏内核。例如，Linux的内核，尽管有些操作系统的功能是作为用户级服务器运行的（如windows系统）。L4、Minix和QNX等内核是以服务器的形式组织的微内核，并在嵌入式环境中得到了广泛的部署。大多数操作系统都采用了进程概念，大多数进程都与xv6的相似。

然而，现代操作系统支持进程可以拥有多个线程，以允许一个进程利用多个CPU。在一个进程中支持多个线程涉及到不少xv6没有的机制，包括潜在的接口变化(如Linux的**clone**，**fork**的变种)，以控制线程共享进程的哪些方面。

## 3 页表

页表是操作系统为每个进程提供自己私有地址空间和内存的机制。页表决定了内存地址的含义，以及物理内存的哪些部分可以被访问。它们允许xv6隔离不同进程的地址空间，并将它们映射到物理内存上。页表还提供了一个间接层次，允许xv6执行一些技巧：在几个地址空间中映射同一内存(trampoline页)，以及用一个未映射页来保护内核和用户的栈。本章其余部分将解释RISC-V硬件提供的页表以及xv6如何使用它们。

### 3.1 分页硬件

提醒一下，RISC-V指令(包括用户和内核)操作的是虚拟地址。机器的RAM，或者说物理内存，是用物理地址来做索引的，RISC-V分页硬件[[1\]](#_ftn1)将这两种地址联系起来，通过将每个虚拟地址映射到物理地址上。

xv6 运行在 Sv39 RISC-V 上，这意味着只使用 64 位虚拟地址的底部 39 位，顶部 25 位未被使用。在这种Sv39配置中，一个RISC-V 页表在逻辑上是一个2^27（134,217,728）***页表项（Page Table Entry, PTE）\***的数组。每个PTE包含一个44位的**物理页号(Physical Page Number，PPN)**和一些标志位。分页硬件通过利用39位中的高27位索引到页表中找到一个**PTE**来转换一个虚拟地址，并计算出一个56位的物理地址，它的前44位来自于**PTE**中的**PPN**，而它的后12位则是从原来的虚拟地址复制过来的。图3.1显示了这个过程，在逻辑上可以把页表看成是一个简单的**PTE**数组（更完整的描述见图3.2）。页表让操作系统控制虚拟地址到物理地址的转换，其粒度为4096（2^12）字节的对齐块。这样的分块称为页。

在Sv39 RISC-V中，虚拟地址的前25位不用于转换地址；将来，RISC-V可能会使用这些位来定义更多的转换层。物理地址也有增长的空间：在**PTE**格式中，物理页号还有10位的增长空间。

![image-20250808160406548](C:\Users\Zenma\AppData\Roaming\Typora\typora-user-images\image-20250808160406548.png)

如图3.2所示，实际转换分三步进行。一个页表以三层树的形式存储在物理内存中。树的根部是一个4096字节的页表页，它包含512个PTE，这些PTE包含树的下一级页表页的物理地址。每一页都包含512个PTE，用于指向下一个页表或物理地址。分页硬件用27位中的顶9位选择根页表页中的PTE，用中间9位选择树中下一级页表页中的PTE，用底9位选择最后的PTE。

如果转换一个地址所需的三个PTE中的任何一个不存在，分页硬件就会引发一个页面错误的异常(***page-fault exception\***)，让内核来处理这个异常（见第4章）。这种三层结构的一种好处是，当有大范围的虚拟地址没有被映射时，可以省略整个页表页。

每个PTE包含标志位，告诉分页硬件如何允许使用相关的虚拟地址。**PTE_V**表示PTE是否存在：如果没有设置，对该页的引用会引起异常（即不允许）。PTE_R控制是否允许指令读取到页。**PTE_W**控制是否允许指令向写该页。**PTE_X**控制CPU是否可以将页面的内容解释为指令并执行。**PTE_U**控制是否允许用户模式下的指令访问页面；如果不设置**PTE_U**，PTE只能在监督者模式下使用。图3.2显示了这一切的工作原理。标志位和与页相关的结构体定义在(kernel/riscv.h)。

![image-20250808160416791](C:\Users\Zenma\AppData\Roaming\Typora\typora-user-images\image-20250808160416791.png)

要告诉硬件使用页表，内核必须将根页表页的物理地址写入**satp**寄存器中。每个CPU都有自己的**satp**寄存器。一个CPU将使用自己的**satp**所指向的页表来翻译后续指令产生的所有地址。每个CPU都有自己的**satp**，这样不同的CPU可以运行不同的进程，每个进程都有自己的页表所描述的私有地址空间。

关于术语的一些说明。物理内存指的是**DRAM**中的存储单元。物理存储器的一个字节有一个地址，称为物理地址。当指令操作虚拟地址时，分页硬件会将其翻译成物理地址，然后发送给DRAM硬件，以读取或写入存储。不像物理内存和虚拟地址，虚拟内存不是一个物理对象，而是指内核提供的管理物理内存和虚拟地址的抽象和机制的集合。

### 3.2 内核地址空间

Xv6为每个进程维护页表，一个是进程的用户地址空间，外加一个内核地址空间的单页表。内核配置其地址空间的布局，使其能够通过可预测的虚拟地址访问物理内存和各种硬件资源。图3.3显示了这个设计是如何将内核虚拟地址映射到物理地址的。文件(kernel/memlayout.h)声明了xv6内核内存布局的常量。

![image-20250808160446376](C:\Users\Zenma\AppData\Roaming\Typora\typora-user-images\image-20250808160446376.png)

QEMU模拟的计算机包含RAM（物理内存），从物理地址**0x80000000**，至少到0x86400000，xv6称之为**PHYSTOP**。QEMU模拟还包括I/O设备，如磁盘接口。QEMU将设备接口作为***memory-mapped(内存映射)\***控制寄存器暴露给软件，这些寄存器位于物理地址空间的**0x80000000**以下。内核可以通过读取/写入这些特殊的物理地址与设备进行交互；这种读取和写入与设备硬件而不是与RAM进行通信。第4章解释了xv6如何与设备交互。

内核使用“直接映射”**RAM**和***内存映射\***设备寄存器，也就是在虚拟地址上映射硬件资源，这些地址与物理地址相等。例如，内核本身在虚拟地址空间和物理内存中的位置都是**KERNBASE=0x80000000**。直接映射简化了读/写物理内存的内核代码。例如，当fork为子进程分配用户内存时，分配器返回该内存的物理地址；**fork**在将父进程的用户内存复制到子进程时，直接使用该地址作为虚拟地址。

有几个内核虚拟地址不是直接映射的:

1．trampoline 页。它被映射在虚拟地址空间的顶端；用户页表也有这个映射。第4章讨论了trampoline 页的作用，但我们在这里看到了页表的一个有趣的用例；一个物理页（存放trampoline代码）在内核的虚拟地址空间中被映射了两次：一次是在虚拟地址空间的顶部，一次是直接映射。

2．内核栈页。每个进程都有自己的内核栈，内核栈被映射到地址高处，所以在它后面xv6可以留下一个未映射的守护页。守护页的PTE是无效的（设置**PTE_V**），这样如果内核溢出内核stack，很可能会引起异常，内核会报错。如果没有防护页，栈溢出时会覆盖其他内核内存，导致不正确的操作。报错还是比较好的

当内核通过高地址映射使用stack时，它们也可以通过直接映射的地址被内核访问。另一种的设计是只使用直接映射，并在直接映射的地址上使用stack。在这种安排中，提供保护页将涉及到取消映射虚拟地址，否则这些地址将指向物理内存，这将很难使用。

内核为trampoline和text(可执行程序的代码段)映射的页会有**PTE_R**和**PTE_X**权限。内核从这些页读取和执行指令。内核映射的其他page会有**PTE_R**和**PTE_W**权限，以便内核读写这些页面的内存。守护页的映射是无效的（设置**PTE_V**）；

### 3.3 物理内存分配

内核必须在运行时为页表、用户内存、内核堆栈和管道缓冲区分配和释放物理内存。 xv6使用内核地址结束到**PHYSTOP**之间的物理内存进行运行时分配。它每次分配和释放整个4096字节的页面。它通过保存空闲页链表，来记录哪些页是空闲的。分配包括从链表中删除一页；释放包括将释放的页面添加到空闲页链表中。

### 3.4 进程地址空间

每个进程都有一个单独的页表，当xv6在进程间切换时，也会改变页表。如图2.3所示，一个进程的用户内存从虚拟地址0开始，可以增长到MAXVA(kernel/riscv.h:348)，原则上允许一个进程寻址256GB的内存。

当一个进程要求xv6提供更多的用户内存时，xv6首先使用**kalloc**来分配物理页，然后将指向新物理页的PTE添加到进程的页表中。然后它将指向新物理页的PTE添加到进程的页表中。Xv6在这些PTE中设置**PTE_W**、**PTE_X**、**PTE_R**、**PTE_U**和**PTE_V**标志。大多数进程不使用整个用户地址空间；xv6使用**PTE_V**来清除不使用的PTE。

我们在这里看到了几个例子，是关于使用页表的。首先，不同的进程页表将用户地址转化为物理内存的不同页，这样每个进程都有私有的用户内存。第二，每个进程都认为自己的内存具有从零开始的连续的虚拟地址，而进程的物理内存可以是不连续的。第三，内核会映射带有**trampoline** 代码的页，该**trampoline**处于用户地址空间顶端，因此，在所有地址空间中都会出现一页物理内存。

![image-20250808160544374](C:\Users\Zenma\AppData\Roaming\Typora\typora-user-images\image-20250808160544374.png)

图3.4更详细地显示了xv6中执行进程的用户内存布局。栈只有一页，图中显示的是由**exec**创建的初始内容。字符串的值，以及指向这些参数的指针数组，位于栈的最顶端。下面是允许程序在**main**启动的值，就像函数**main(argc, argv)**刚刚被调用一样。

为了检测用户栈溢出分配的栈内存，xv6会在stack的下方放置一个无效的保护页。如果用户栈溢出，而进程试图使用栈下面的地址，硬件会因为该映射无效而产生一个页错误异常。现实世界中的操作系统可能会在用户栈溢出时自动为其分配更多的内存。

### 3.5 真实世界的情况

像大多数操作系统一样，xv6使用分页硬件进行内存保护和映射。大多数操作系统对分页的使用要比xv6复杂得多，它将分页和分页错误异常结合起来，我们将在第4章中讨论。

Xv6的内核使用虚拟地址和物理地址之间的直接映射，这样会更简单，并假设在地址0x8000000处有物理RAM，即内核期望加载的地方。这在QEMU中是可行的，但是在真实的硬件上，它被证明是一个糟糕的想法；真实的硬件将RAM和设备放置在不可预测的物理地址上，例如在0x8000000处可能没有RAM，而xv6期望能够在那里存储内核。更好的内核设计利用页表将任意的硬件物理内存布局变成可预测的内核虚拟地址布局。

RISC-V支持物理地址级别的保护，但xv6没有使用该功能。

在有大量内存的机器上，使用RISC-V对超级页(4MB的页)的支持可能是有意义的。当物理内存很小的时候，小页是有意义的，可以精细地分配和分页到磁盘。例如，如果一个程序只使用8千字节的内存，那么给它整整4兆字节的超级物理内存页是浪费的。更大的页在有大量内存的机器上是有意义的，可以减少页表操作的开销。

xv6内核缺乏一个类malloc的分配器为小程序提供内存，这使得内核没有使用需要动态分配的复杂数据结构，从而简化了设计。

内存分配是一个常年的热门话题，基本问题是有效利用有限的内存和为未来未知的请求做准备[7]。如今人们更关心的是速度而不是空间效率。此外，一个更复杂的内核可能会分配许多不同大小的小块，而不是（在xv6中）只分配4096字节的块；一个真正的内核分配器需要处理小块分配以及大块分配。

## 4 陷阱与系统调用

有三种事件会导致CPU搁置普通指令的执行，强制将控制权转移给处理该事件的特殊代码。一种情况是***系统调用\***，当用户程序执行**ecall**指令要求内核为其做某事时。另一种情况是***异常\***：一条指令（用户或内核）做了一些非法的事情，如除以零或使用无效的虚拟地址。第三种情况是设备***中断\***，当一个设备发出需要注意的信号时，例如当磁盘硬件完成一个读写请求时。

本书使用***trap\***作为这些情况的通用术语。通常，代码在执行时发生trap，之后都会被恢复，而且不需要意识到发生了什么特殊的事情。也就是说，我们通常希望trap是透明的；这一点对于中断来说尤其重要，被中断的代码通常不会意识到会发生trap。通常的顺序是：trap迫使控制权转移到内核；内核保存寄存器和其他状态，以便恢复执行；内核执行适当的处理程序代码（例如，系统调用实现或设备驱动程序）；内核恢复保存的状态，并从trap中返回；代码从原来的地方恢复。

xv6内核会处理所有的trap。这对于系统调用来说是很自然的。这对中断来说也是合理的，因为隔离要求用户进程不能直接使用设备，而且只有内核才有设备处理所需的状态。这对异常处理来说也是合理的，因为xv6响应所有来自用户空间的异常，并杀死该违规程序。

Xv6 trap 处理分为四个阶段：RISC-V CPU采取的硬件行为，为内核C代码准备的汇编入口，处理trap的C 处理程序，以及系统调用或设备驱动服务。虽然三种trap类型之间的共性表明，内核可以用单一的代码入口处理所有的trap，但事实证明，为三种不同的情况，即来自用户空间的trap、来自内核空间的trap和定时器中断，设置单独的汇编入口和C trap处理程序是很方便的。

### 4.1 RISC-V 陷阱机制

每个RISC-V CPU都有一组控制寄存器，内核写入这些寄存器来告诉CPU如何处理trap，内核可以通过读取这些寄存器来发现已经发生的trap。RISC-V文档包含了完整的叙述[1]。riscv.h（kernel/riscv.h:1）包含了xv6使用的定义。这里是最重要的寄存器的概述。

l  **stvec**：内核在这里写下trap处理程序的地址；RISC-V到这里来处理trap。

l  **sepc**：当trap发生时，RISC-V会将程序计数器保存在这里（因为**PC**会被**stvec**覆盖）。**sret**(从trap中返回)指令将**sepc**复制到pc中。内核可以写**sepc**来控制**sret**的返回到哪里。

l  **scause**：RISC -V在这里放了一个数字，描述了trap的原因。

l  **sscratch**：内核在这里放置了一个值，这个值会方便trap 恢复/储存用户上下文。

l  **sstatus**:：**sstatus**中的**SIE**位控制设备中断是否被启用，如果内核清除**SIE**，RISC-V将推迟设备中断，直到内核设置**SIE**。如果内核清除**SIE**，RISC-V将推迟设备中断，直到内核设置**SIE**。**SPP**位表示trap是来自用户模式还是监督者模式，并控制**sret**返回到什么模式。

 

上述寄存器与在监督者模式下处理的trap有关，在用户模式下不能读或写。对于机器模式下处理的trap，有一组等效的控制寄存器；xv6只在定时器中断的特殊情况下使用它们。

多核芯片上的每个CPU都有自己的一组这些寄存器，而且在任何时候都可能有多个CPU在处理一个trap。

当需要执行trap时，RISC-V硬件对所有的trap类型（除定时器中断外）进行以下操作：

1. 如果该trap是设备中断，且**sstatus** **SIE**位为0，则不要执行以下任何操作。
2. 通过清除SIE来禁用中断。
3. 复制pc到**sepc**
4. 将当前模式(用户或监督者)保存在sstatus的**SPP**位。
5. 在**scause**设置该次trap的原因。
6. 将模式转换为监督者。
7. 将**stvec**复制到pc。
8. 执行新的pc

注意，CPU不会切换到内核页表，不会切换到内核中的栈，也不会保存pc以外的任何寄存器。内核软件必须执行这些任务。CPU在trap期间做很少的工作的一个原因是为了给软件提供灵活性，例如，一些操作系统在某些情况下不需要页表切换，这可以提高性能。

你可能会想CPU的trap处理流程是否可以进一步简化。例如，假设CPU没有切换程序计数器（pc）。那么trap可以切换到监督者模式时，还在运行用户指令。这些用户指令可以打破用户空间/内核空间的隔离，例如通过修改satp寄存器指向一个允许访问所有物理内存的页表。因此，CPU必须切换到内核指定的指令地址，即**stvec**。

### 4.2 用户空间的陷入

在用户空间执行时，如果用户程序进行了系统调用(**ecall**指令)，或者做了一些非法的事情，或者设备中断，都可能发生trap。来自用户空间的trap的处理路径是**uservec**(kernel/trampoline.S:16)，然后是**usertrap**(kernel/trap.c:37)；返回时是**usertrapret**(kernel/trap.c:90)，然后是**userret**(kernel/trampoline.S:16)。

来自用户代码的trap比来自内核的trap更具挑战性，因为**satp**指向的用户页表并不映射内核，而且栈指针可能包含一个无效甚至恶意的值。

因为RISC-V硬件在trap过程中不切换页表，所以用户页表必须包含**uservec**的映射，即**stvec**指向的trap处理程序地址。**uservec**必须切换**satp**，使其指向内核页表；为了在切换后继续执行指令，**uservec**必须被映射到内核页表与用户页表相同的地址。

Xv6用一个包含**uservec**的trampoline页来满足这些条件。Xv6在内核页表和每个用户页表中的同一个虚拟地址上映射了trampoline页。这个虚拟地址就是**TRAMPOLINE** （如我们在图2.3和图3.3中看到的）。**trampoline.S**中包含trampoline的内容，（执行用户代码时）**stvec**设置为**uservec**（kernel/trampoline.S:16）。

当**uservec**启动时，所有32个寄存器都包含被中断的代码所拥有的值。但是**uservec**需要能够修改一些寄存器，以便设置satp和生成保存寄存器的地址。RISC-V通过**sscratch**寄存器提供了帮助。**uservec**开始时的**csrrw**指令将**a0**和**sscratch**的内容互换。现在用户代码的**a0**被保存了；**uservec**有一个寄存器（**a0**）可以使用；**a0**包含了内核之前放在**sscratch**中的值。

**uservec**的下一个任务是保存用户寄存器。在进入用户空间之前，内核先设置**sscratch**指向该进程的**trapframe**，这个**trapframe**可以保存所有用户寄存器（kernel/proc.h:44）。因为**satp**仍然是指用户页表，所以**uservec**需要将**trapframe**映射到用户地址空间中。当创建每个进程时，xv6为进程的**trapframe**分配一页内存，并将它映射在用户虚拟地址**TRAPFRAME**，也就是**TRAMPOLINE**的下面。进程的**p->trapframe**也指向**trapframe**，不过是指向它的物理地址[[1\]](#_ftn1)，这样内核可以通过内核页表来使用它

因此，在交换**a0**和**sscratch**后，**a0**将指向当前进程的**trapframe**。**uservec** 将在**trapframe**保存全部的寄存器，包括从**sscratch**读取的**a0**。

trapframe包含指向当前进程的内核栈、当前CPU的**hartid**、**usertrap**的地址和内核页表的地址的指针，**uservec**将这些值设置到相应的寄存器中，并将**satp**切换到内核页表和刷新TLB，然后调用**usertrap**。

**usertrap**的作用是确定trap的原因，处理它，然后返回(kernel/ trap.c:37)。如上所述，它首先改变**stvec**，这样在内核中发生的trap将由**kernelvec**处理。它保存了**sepc**(用户PC)，这也是因为**usertrap**中可能会有一个进程切换，导致**sepc**被覆盖。如果trap是系统调用，**syscall**会处理它；如果是设备中断，**devintr**会处理；否则就是异常，内核会杀死故障进程。**usertrap**会把用户pc加4，因为RISC-V在执行系统调用时，会留下指向**ecall**指令的程序指针[[2\]](#_ftn2)。在退出时，**usertrap**检查进程是否已经被杀死或应该让出CPU（如果这个trap是一个定时器中断）。

回到用户空间的第一步是调用usertrapret(kernel/trap.c:90)。这个函数设置RISC-V控制寄存器，为以后用户空间trap做准备。这包括改变**stvec**来引用**uservec**，准备**uservec**所依赖的**trapframe**字段，并将**sepc**设置为先前保存的用户程序计数器。最后，**usertrapret**在用户页表和内核页表中映射的trampoline页上调用**userret**，因为**userret**中的汇编代码会切换页表。

**usertrapret**对**userret**的调用传递了参数**a0，a1， a0**指向TRAPFRAME，**a1**指向用户进程页表(kernel/trampoline.S:88)，**userret**将**satp**切换到进程的用户页表。回想一下，用户页表同时映射了trampoline页和**TRAPFRAME**，但没有映射内核的其他内容。同样，事实上，在用户页表和内核页表中，trampoline页被映射在相同的虚拟地址上，这也是允许**uservec**在改变**satp**后继续执行的原因。**userret**将**trapframe**中保存的用户**a0**复制到**sscratch**中，为以后与**TRAPFRAME**交换做准备。从这时开始，**userret**能使用的数据只有寄存器内容和**trapframe**的内容。接下来**userret**从**trapframe**中恢复保存的用户寄存器，对**a0**和**sscratch**做最后的交换，恢复用户a0并保存TRAPFRAME，为下一次trap做准备，并使用**sret**返回用户空间。

### 4.3 内核空间的陷入

Xv6对异常的响应是相当固定：如果一个异常发生在用户空间，内核就会杀死故障进程。如果一个异常发生在内核中，内核就会**panic**。真正的操作系统通常会以更有趣的方式进行响应。

举个例子，许多内核使用页面故障来实现***写时复制（copy-on-write，cow）\*fork**。要解释写时复制fork，可以想一想xv6的fork，在第3章中介绍过。fork通过调用**uvmcopy(kernel/vm.c:309**)为子进程分配物理内存，并将父进程的内存复制到子程序中，使子进程拥有与父进程相同的内存内容。如果子进程和父进程能够共享父进程的物理内存，效率会更高。然而，直接实现这种方法是行不通的，因为父进程和子进程对共享栈和堆的写入会中断彼此的执行。

通过使用写时复制fork，可以让父进程和子进程安全地共享物理内存，通过页面故障来实现。当CPU不能将虚拟地址翻译成物理地址时，CPU会产生一个页面故障异常(page-fault     exception)。 RISC-V有三种不同的页故障：load页故障（当加载指令不能翻译其虚拟地址时）、stote页故障（当存储指令不能翻译其虚拟地址时）和指令页故障（当指令的地址不能翻译时）。**scause**寄存器中的值表示页面故障的类型，**stval**寄存器中包含无法翻译的地址。

***COW\***  fork中的基本设计是父进程和子进程最初共享所有的物理页面，但将它们映射设置为只读。因此，当子进程或父进程执行store指令时，RISC-V CPU会引发一个页面故障异常。作为对这个异常的响应，内核会拷贝一份包含故障地址的页。然后将一个副本的读/写映射在子进程地址空间，另一个副本的读/写映射在父进程地址空间。更新页表后，内核在引起故障的指令处恢复故障处理。因为内核已经更新了相关的PTE，允许写入，所以现在故障指令将正常执行。

这个COW设计对fork很有效，因为往往子程序在fork后立即调用exec，用新的地址空间替换其地址空间。在这种常见的情况下，子程序只会遇到一些页面故障，而内核可以避免进行完整的复制。此外，COW fork是透明的：不需要对应用程序进行修改，应用程序就能受益。

页表和页故障的结合，将会有更多种有趣的可能性的应用。另一个被广泛使用的特性叫做***懒分配 (lazy allocation)\***，它有两个部分。首先，当一个应用程序调用**sbrk**时，内核会增长地址空间，但在页表中把新的地址标记为无效。第二，当这些新地址中的一个出现页面故障时，内核分配物理内存并将其映射到页表中。由于应用程序经常要求获得比他们需要的更多的内存，所以懒分配是一个胜利：内核只在应用程序实际使用时才分配内存。像COW fork一样，内核可以对应用程序透明地实现这个功能。

另一个被广泛使用的利用页面故障的功能是从***磁盘上分页(paging from disk)\***。如果应用程序需要的内存超过了可用的物理RAM，内核可以交换出一些页：将它们写入一个存储设备，比如磁盘，并将其PTE标记为无效。如果一个应用程序读取或写入一个被换出到磁盘的页，CPU将遇到一个页面故障。内核就可以检查故障地址。如果该地址属于磁盘上的页面，内核就会分配一个物理内存的页面，从磁盘上读取页面到该内存，更新PTE为有效并引用该内存，然后恢复应用程序。为了给该页腾出空间，内核可能要交换另一个页。这个特性不需要对应用程序进行任何修改，如果应用程序具有引用的位置性（即它们在任何时候都只使用其内存的一个子集），这个特性就能很好地发挥作用。

其他结合分页和分页错误异常的功能包括自动扩展堆栈和内存映射文件。

### 4.4 真实世界的情况

如果将内核内存映射到每个进程的用户页表中（使用适当的PTE权限标志），就不需要特殊的trampoline页了。这也将消除从用户空间trap进入内核时对页表切换的需求。这也可以让内核中的系统调用实现利用当前进程的用户内存被映射的优势，让内核代码直接去间接引用（对地址取值）用户指针。许多操作系统已经使用这些想法来提高效率。Xv6没有实现这些想法，以减少由于无意使用用户指针而导致内核出现安全漏洞的机会，并减少一些复杂性，以确保用户和内核虚拟地址不重叠。

## 5 中断与设备驱动

***驱动\***是操作系统中管理特定设备的代码，他有如下功能：1、配置设备相关的硬件，2、告诉设备需要怎样执行，3、处理设备产生的中断，4、与等待设备I/O的进程进行交互。驱动程序的代码写起来可能很棘手，因为驱动程序与它所管理的设备会同时执行。此外，驱动程序编写人员必须了解设备的硬件接口，但硬件接口可能是很复杂的，而且文档不够完善。

需要操作系统关注的设备通常可以被配置为产生中断，这是trap的一种类型。内核trap处理代码可以知道设备何时引发了中断，并调用驱动的中断处理程序；在xv6中，这个处理发生在**devintr**(kernel/trap.c:177)中。

许多设备驱动程序在两个context中执行代码：上半部分(***top half\***)在进程的内核线程中运行，下半部分(***bottom half\***)在中断时执行。上半部分是通过系统调用，如希望执行I/O的 read和write。这段代码可能会要求硬件开始一个操作（比如要求磁盘读取一个块）；然后代码等待操作完成。最终设备完成操作并引发一个中断。驱动程序的中断处理程序，作为**下半部分**，推算出什么操作已经完成，如果合适的话，唤醒一个等待该操作的进程，并告诉硬件执行下一个操作。

### 5.1 终端输入

控制台驱动**(console.c)**是驱动结构的一个简单说明。控制台驱动通过连接到RISC-V上的UART串行端口硬件，接受输入的字符。控制台驱动程序每次累计一行输入，处理特殊的输入字符，如退格键和control-u。用户进程，如shell，使用**read**系统调用从控制台获取输入行。当你在QEMU中向xv6输入时，你的按键会通过QEMU的模拟UART硬件传递给xv6。

与驱动交互的UART硬件是由QEMU仿真的16550芯片[11]。在真实的计算机上，16550将管理一个连接到终端或其他计算机的RS232串行链接。当运行QEMU时，它连接到你的键盘和显示器上。

UART硬件在软件看来是一组**内存映射**的控制寄存器。也就是说，有一些RISC-V硬件的物理内存地址会连接到UART设备，因此加载和存储与设备硬件而不是RAM交互。UART的内存映射地址从0x10000000开始，即**UART0**（kernel/memlayout.h:21）。这里有一些UART控制寄存器，每个寄存器的宽度是一个字节。它们与UART0的偏移量定义在(kernel/uart.c:22)。例如，**LSR**寄存器中一些位表示是否有输入字符在等待软件读取。这些字符（如果有的话）可以从**RHR**寄存器中读取。每次读取一个字符，UART硬件就会将其从内部等待字符的FIFO中删除，并在FIFO为空时清除**LSR**中的就绪位。UART传输硬件在很大程度上是独立于接收硬件的，如果软件向**THR**写入一个字节，UART就会发送该字节。

Xv6的**main**调用**consoleinit**（kernel/console.c:184）来初始化UART硬件。这段代码配置了UART，当UART接收到一个字节的输入时，就产生一个接收中断，当UART每次完成发送一个字节的输出时，产生一个***传输完成(transmit complete)\***中断(kernel/uart.c:53)。

xv6 shell通过**init.c**(user/init.c:19)打开的文件描述符从控制台读取。**consoleread**等待输入的到来(通过中断)，输入会被缓冲在**cons.buf**，然后将输入复制到用户空间，再然后(在一整行到达后)返回到用户进程。如果用户还没有输入完整的行，任何**read**进程将在**sleep**调用中等待(kernel/console.c:98)(第7章解释了sleep的细节)。

当用户键入一个字符时，UART硬件向RISC-V抛出一个中断，从而激活xv6的**trap**处理程序。trap处理程序调用devintr(kernel/trap.c:177)，它查看RISC-V的**scause**寄存器，发现中断来自一个外部设备。然后它向一个叫做PLIC[1]的硬件单元询问哪个设备中断了(kernel/trap.c:186)。如果是UART，**devintr**调用**uartintr**。

**uartintr** (kernel/uart.c:180) 从**UART**硬件中读取在等待的输入字符，并将它们交给**consoleintr** (kernel/console.c:138)；它不会等待输入字符，因为以后的输入会引发一个新的中断。**consoleintr**的工作是将中输入字符积累**cons.buf**中，直到有一行字符。 **consoleintr**会特别处理退格键和其他一些字符。当一个新行到达时，**consoleintr**会唤醒一个等待的**consoleread**（如果有的话）。

一旦被唤醒，**consoleread**将会注意到**cons.buf**中的完整行，并将其将其复制到用户空间，并返回（通过系统调用）到用户空间。

### 5.2 终端输出

向控制台写数据的**write**系统调用最终会到达**uartputc**(kernel/uart.c:87)。设备驱动维护了一个输出缓冲区(**uart_tx_buf**)，这样写入过程就不需要等待UART完成发送；相反，**uartputc**将每个字符追加到缓冲区，调用**uartstart**来启动设备发送(如果还没有的话)，然后返回。**Uartputc**只有在缓冲区满的时候才会等待。

​    每次UART发送完成一个字节，它都会产生一个中断。**uartintr**调用**uartstart**，**uartintr**检查设备是否真的发送完毕，并将下一个缓冲输出字符交给设备，每当UART发送完一个字节，就会产生一个中断。因此，如果一个进程向控制台写入多个字节，通常第一个字节将由uartputc s调用uartstart发送，其余的缓冲字节将由uartintr调用uartstart发送，因为发送完成中断到来。

**uartintr**调用**uartstart**，**uartintr**查看设备是否真的发送完成，并将下一个缓冲输出字符交给设备，每当UART发送完一个字节，就会产生一个中断。因此，如果一个进程向控制台写入多个字节，通常第一个字节将由**uartputc**对**uartstart**的调用发送，其余的缓冲字节将随着发送完成中断的到来由**uartintr**的**uartstart**调用发送。

有一个通用模式需要注意，设备活动和进程活动需要解耦，这将通过缓冲和中断来实现。控制台驱动程序可以处理输入，即使没有进程等待读取它；随后的读取将看到输入。同样，进程可以发送输出字节，而不必等待设备。这种解耦可以通过允许进程与设备I/O并发执行来提高性能，当设备速度很慢（如UART）或需要立即关注（如打印键入的字节）时，这种解耦尤为重要。这个idea有时被称为***I/O并发\***。

### 5.3 时钟中断

Xv6使用定时器中断来维护它的时钟，并使它能够切换正在运行的进程；**usertrap**和**kerneltrap**中的**yield**调用会导致这种切换。每个RISC-V CPU的时钟硬件都会抛出时钟中断。Xv6对这个时钟硬件进行编程，使其定期中断相应的CPU。

RISC-V要求在机器模式下处理定时器中断，而不是监督者模式。RISCV机器模式执行时没有分页，并且有一套单独的控制寄存器，因此在机器模式下运行普通的xv6内核代码是不实用的。因此，xv6对定时器中断的处理与上面谈到的trap机制完全分离了。

在main执行之前的**start.c**，是在机器模式下执行的，设置了接收定时器中断(kernel/start.c:57)。一部分工作是对**CLINT**硬件（**core-local interruptor**）进行编程，使其每隔一定时间产生一次中断。另一部分是设置一个类似于**trapframe**的**scratch**区域，帮助定时器中断处理程序保存寄存器和**CLINT**寄存器的地址。最后，**start**将**mtvec**设置为**timervec**，启用定时器中断。

定时器中断可能发生在用户或内核代码执行的任何时候；内核没有办法在关键操作中禁用定时器中断。因此，定时器中断处理程序必须以保证不干扰被中断的内核代码的方式进行工作。基本策略是处理程序要求RISC-V引发一个软件中断并立即返回。RISC-V用普通的trap机制将软件中断传递给内核，并允许内核禁用它们。处理定时器中断产生的软件中断的代码可以在**devintr**（kernel/trap.c:204）中看到。

机器模式的定时器中断向量是**timervec**(kernel/kernelvec.S:93)。它在**start**准备的**scratch**区域保存一些寄存器，告诉**CLINT**何时产生下一个定时器中断，使RISC-V产生一个软件中断，恢复寄存器，然后返回。在定时器中断处理程序中没有C代码。

### 5.4 真实世界的情况

Xv6允许在内核和用户程序执行时使用设备和定时器中断。定时器中断可以强制从定时器中断处理程序进行线程切换（调用**yield**），即使是在内核中执行。如果内核线程有时会花费大量的时间进行计算，而不返回用户空间，那么在内核线程之间公平地对CPU进行时间划分的能力是很有用的。然而，内核代码需要注意它可能会被暂停（由于定时器中断），然后在不同的CPU上恢复，这是xv6中一些复杂的根源。如果设备和定时器中断只发生在执行用户代码时，内核可以变得更简单一些。

在一台典型的计算机上支持所有设备的全貌是一件很辛苦的事情，因为设备很多，设备有很多功能，设备和驱动程序之间的协议可能很复杂，而且文档也不完善。在许多操作系统中，驱动程序所占的代码比核心内核还多。

在一台正常的计算机上支持所有设备是一件很辛苦的事情，因为设备很多，设备有很多功能，设备和驱动程序之间的协议可能很复杂，而且文档也不完善。在许多操作系统中，驱动程序所占的代码比核心内核还多。

UART驱动器通过读取UART控制寄存器，一次检索一个字节的数据；这种模式被称为编程I/O，因为软件在驱动数据移动。程序化I/O简单，但速度太慢，无法在高数据速率下使用。需要高速移动大量数据的设备通常使用直接内存访问（DMA）。DMA设备硬件直接将传入数据写入RAM，并从RAM中读取传出数据。现代磁盘和网络设备都使用DMA。DMA设备的驱动程序会在RAM中准备数据，然后使用对控制寄存器的一次写入来告诉设备处理准备好的数据。

UART驱动器通过读取UART控制寄存器，一次读取一个字节的数据；这种模式被称为编程I/O，因为软件在控制数据移动。程序化I/O简单，但速度太慢，无法在高数据速率下使用。需要高速移动大量数据的设备通常使用***直接内存访问(direct memory access, DMA)\***。DMA设备硬件直接将传入数据写入RAM，并从RAM中读取传出数据。现代磁盘和网络设备都使用DMA。DMA设备的驱动程序会在RAM中准备数据，然后使用对控制寄存器的一次写入来告诉设备处理准备好的数据。

当设备在不可预知的时间需要关注时，中断是很有用的，而且不会太频繁。但中断对CPU的开销很大。因此，高速设备，如网络和磁盘控制器，使用了减少对中断需求的技巧。其中一个技巧是对整批传入或传出的请求提出一个单一的中断。另一个技巧是让驱动程序完全禁用中断，并定期检查设备是否需要关注。这种技术称为***轮询（polling）\***。如果设备执行操作的速度非常快，轮询是有意义的，但如果设备大部分时间处于空闲状态，则会浪费CPU时间。一些驱动程序会根据当前设备的负载情况，在轮询和中断之间动态切换。

UART驱动首先将输入的数据复制到内核的缓冲区，然后再复制到用户空间。这在低数据速率下是有意义的，但对于那些快速生成或消耗数据的设备来说，这样的双重拷贝会大大降低性能。一些操作系统能够直接在用户空间缓冲区和设备硬件之间移动数据，通常使用DMA。

## 6 调度

任何操作系统运行的进程数量都可能超过计算机的CPU数量，因此需要制定一个方案，在各进程之间分时共享CPU。理想情况下，这种共享对用户进程是透明的。一种常见的方法是通过将进程复用到硬件CPU上，给每个进程提供它有自己的虚拟CPU的假象。本章解释xv6如何实现这种复用。

### 6.1 复用

xv6通过在两种情况下将CPU从一个进程切换到另一个进程来实现复用。首先，xv6的**sleep**和**wakeup**机制会进行切换，这会发生在进程等待设备或管道I/O，或等待子进程退出，或在**sleep**系统调用中等待。其次，xv6周期性地强制切换，以应对长时间的计算进程。这种复用造成了每个进程都有自己的CPU的假象，就像xv6使用内存分配器和硬件页表造成每个进程都有自己的内存的假象一样。

实现复用会有一些挑战。首先，如何从一个进程切换到另一个进程？虽然上下文切换的想法很简单，但实现起来却很难。第二，如何对用户进程透明的强制切换？xv6采用一般的方式，用定时器中断来驱动上下文切换。第三，许多CPU可能会在进程间并发切换，需要设计一个锁来避免竞争。第四，当进程退出时，必须释放进程的内存和其他资源，但它自己不能做到这一切，因为它不能释放自己的内核栈，同时又在使用内核栈。第五，多核机器的每个内核必须记住它正在执行的进程，这样系统调用就会修改相应进程的内核状态。最后，**sleep**和**wakeup**允许一个进程放弃CPU，并睡眠等待事件，并允许另一个进程唤醒第一个进程。需要注意一些竞争可能会使唤醒丢失。Xv6试图尽可能简单地解决这些问题，但尽管如此，写出来代码还是很棘手。

### 6.2 上下文切换

![image-20250808162654776](C:\Users\Zenma\AppData\Roaming\Typora\typora-user-images\image-20250808162654776.png)

图7.1概述了从一个用户进程切换到另一个用户进程所涉及的步骤：用户内核转换（系统调用或中断）到旧进程的内核线程，context切换到当前CPU的调度器线程，context切换到新进程的内核线程，以及trap返回到用户级进程。xv6调度器在每个CPU上有一个专门的线程(保存的寄存器和栈)，因为调度器在旧进程的内核栈上执行是不安全的：其他核心可能会唤醒进程并运行它，而且在两个不同的核心上使用相同的栈将是一场灾难。在本节中，我们将研究在内核线程和调度线程之间切换的机制。

从一个线程切换到另一个线程，需要保存旧线程的CPU寄存器，并恢复新线程之前保存的寄存器；栈指针和pc被保存和恢复，意味着CPU将切换栈和正在执行的代码。

函数**swtch**执行内核线程切换的保存和恢复。**swtch**并不直接知道线程，它只是保存和恢复寄存器组，称为***上下文(context)\***。当一个进程要放弃CPU的时候，进程的内核线程会调用**swtch**保存自己的上下文并返回到调度器上下文。每个上下文都包含在一个结构体 **context(kernel/proc.h:2)**中，它本身包含在进程的结构体**proc**或CPU的结构体**cpu**中。**Swtch**有两个参数：**struct context \*old**和**struct context \*new**。它将当前的寄存器保存在old中，从new中加载寄存器，然后返回。

让我们跟随一个进程通过**swtch**进入**scheduler**。我们在第4章看到，在中断结束时，有一种情况是**usertrap**调用**yield**。**yield**又调用**sched**，**sched**调用**swtch**将当前上下文保存在**p->context**中，并切换到之前保存在**cpu->scheduler**中的调度器上下文（kernel/proc.c:509）。

**Swtch(kernel/swtch.S:3)**只保存callee-saved寄存器，caller-saved寄存器由调用的C代码保存在堆栈上(如果需要)。**Swtch**知道**struct context**中每个寄存器字段的偏移量。它不保存pc。相反，**swtch**保存了ra寄存器[[1\]](#_ftn1)，它保存了**swtch**应该返回的地址。现在，**swtch**从新的上下文中恢复寄存器，新的上下文中保存着前一次**swtch**所保存的寄存器值。当**swtch**返回时，它返回到被恢复的ra寄存器所指向的指令，也就是新线程之前调用**swtch**的指令。此外，它还会在新线程的栈上返回。

在我们的例子中，**sched**调用**swtch**切换到**cpu->scheduler**，即CPU的调度上下文。这个上下文已经被调度器对**swtch**的调用所保存(kernel/proc.c:475)。当我们跟踪的**swtch**返回时，它不是返回到**sched**而是返回到**scheduler**，它的栈指针指向当前CPU的调度器栈。

### 6.3 调度器

上一节研究了**swtch**的低级细节，现在我们把**swtch**作为一个给定的条件，研究从一个进程的内核线程通过调度器切换到另一个进程。调度器以CPU特殊线程的形式存在，线程运行**scheduler**函数。这个函数负责选择下一步运行哪个进程。一个想要放弃CPU的进程，必须获取自己的进程锁**p->lock**，释放它所持有的其他锁，更新自己的状态（**p->state**），然后调用**sched**。**Yield** (kernel/proc.c:515)做到了这些，就像我们稍后要研究的**sleep**和**exit**一样。**Sched**对这些条件进行仔细检查(kernel/proc.c:499-504)，这些条件表明：因为锁被持有，所以中断应该被禁止。最后，**sched**调用**swtch**保存**p->context**中的当前上下文，并在**cpu->scheduler**中切换到调度器上下文。调度器继续for循环，找到一个要运行的进程，切换到它，然后循环重复。

我们刚刚看到xv6在调用**swtch**的过程中持有**p->lock**：**swtch**的调用者必须已经持有锁，而锁的控制权则传递给切换到的代码。这种约定对于锁来说是不寻常的；通常获得锁的线程也要负责释放锁。对于上下文切换来说，有必要打破这个约定，因为**p->lock**保护了进程的状态和**context**字段上的***不变式(invariant)\***，而这些不变式在**swtch**中执行时为**false**。如果**p->lock**在**swtch**过程中不被持有，可能会出现问题的一个情况：在**yield**将其状态设置为**RUNNABLE**之后，但在**swtch**切换到新的栈之前，其他CPU可能会运行这个进程。结果就是两个CPU运行在同一个栈上，这是不正确的。

一个内核线程在**sched**中放弃它的CPU，并且总是切换到调度器的同一个位置，而调度器（几乎）总是切换到之前调用**sched**的某个内核线程。因此，如果把xv6切换线程的行号打印出来，就会观察到下面的结果：(kernel/proc.c:475)，(kernel/proc.c:509)，(kernel/proc.c:475)，(kernel/proc.c:509)，等等。在两个线程之间发生这种风格化切换的程序有时被称为***协程(coroutine)\***；在这个例子中，**sched**和调度器是彼此的***coroutines\***。

当一个新的进程第一次被调度时，它开始于**forkret** (kernel/proc.c:527)。**Forkret**的存在是为了释放**p->lock**，否则，新进程需要从**usertrapret**开始执行。

**scheduler(kernel/proc.c:457)**运行了一个简单的循环：找到一个可以运行进程，运行它，直到它让出CPU，一直重复。调度器在进程表上循环寻找一个可运行的进程，即p->state == RUNNABLE的进程。一旦找到这样的进程，它就会设置CPU当前进程c->proc，将该进程标记为RUNNING，然后调用**swtch**开始运行它(kernel/proc.c:470- 475)。

你可以这样理解调度代码结构，它执行一组关于进程的不变式，并且每当这些不变式为**False**时，就持有**p->lock**。一个不变式是，如果一个进程正在运行，定时器中断的**yield**必须能够安全地切换进程；这意味着CPU寄存器必须持有进程的寄存器值（即**swtch**没有将它们移到上下文中），并且**c->proc**必须指向该进程。另一个不变式是，如果一个进程是**RUNNABLE**的，那么对于一个空闲的CPU调度器来说，运行它必须是安全的；这意味着  （1）**p->context**必须拥有进程的寄存器（i.e., 它们实际上并不在真实的寄存器中），（2）没有CPU在进程的内核栈上执行，（3）也没有CPU的c->proc指向进程。请注意，当p->lock被持有时，这些属性往往不为真。

维护上述不变式的原因：xv6经常在一个线程中获取**p->lock**，然后在另一个线程中释放，例如在**yield**中获取，在**schedululer**中释放。一旦**yield**开始修改一个正在运行的进程的状态，使其成为**RUNNABLE**，锁必须一直保持，直到不变式被恢复：最早正确的释放点是在调度器（运行在自己的堆栈上）清除**c->proc**之后。同样，一旦调度器开始将一个**RUNNABLE**进程转换为**RUNNING**，锁就不能被释放，直到内核线程完成运行（在**swtch**之后，例如在**yield**中）。

**p->lock**也保护其他的东西：**exit**和**wait**之间的相互作用，避免丢失唤醒的机制（见第7.5节），以及避免进程退出和其他进程读写其状态之间的竞争（例如，**exit**系统调用查看**p->pid**并设置**p->killed (kernel/proc.c:611)**。值得思考的是，是否可以将**p->lock**的不同功能拆分开来，这样既清晰，也可能提高性能。

### 6.4 等待，退出与杀死进程

**sleep**和**wakeup**可以用于许多种需要等待的情况。在第1章中介绍的一个有趣的例子是，一个子进程的**exit**和其父进程的**wait**之间的交互。在子进程退出的时候，父进程可能已经在**wait**中睡眠了，也可能在做别的事情；在后一种情况下，后续的**wait**调用必须观察子进程的退出，也许是在它调用**exit**之后很久。xv6在**wait**观察到子进程退出之前，记录子进程退出的方式是让**exit**将调用进程设置为**ZOMBIE**状态，在那里停留，直到父进程的**wait**注意到它，将子进程的状态改为**UNUSED**，复制子进程的退出状态，并将子进程的进程ID返回给父进程。如果父进程比子进程先退出，父进程就把子进程交给**init**进程，而**init**进程则循环的调用**wait**；这样每个子进程都有一个“父进程”来清理。主要的实现挑战是父进程和子进程的**wait**和**exit**，以及**exit**和**exit**之间可能出现竞争和死锁的情况。

**Wait**使用*调用进程* 的**p->lock**作为条件锁，以避免唤醒丢失，它在开始时获取该锁（kernel/proc.c:398）。然后它扫描进程表。如果它发现一个处于**ZOMBIE**状态的子进程，它释放这个子进程的资源和它的**proc**结构，将子进程的退出状态复制到提供给**wait**的地址(如果它不是0)，并返回子进程的ID。如果**wait**找到了子进程但没有一个退出，它调用**sleep**等待其中一个子进程退出(kernel/proc.c:445)，然后再次扫描。这里，在**sleep**中释放的条件锁是等待进程的p->lock，也就是上面提到的特殊情况。请注意，**wait**经常持有两个锁；它在试图获取任何子锁之前，会先获取自己的锁；因此xv6的所有锁都必须遵守相同的锁顺序（父进程的锁，然后是子进程的锁），以避免死锁。

**Wait**会查看每个进程的**np->parent**来寻找它的子进程。它使用 **np->parent** 而不持有 **np->lock**，这违反了共享变量必须受锁保护的通常规则。但是**np**有可能是当前进程的祖先，在这种情况下，获取**np->lock**可能会导致死锁，因为这违反了上面提到的顺序。在这种情况下，在没有锁的情况下检查**np->parent**似乎是安全的；一个进程的父进程字段只有“父亲“改变，所以如果**np->parent==p**为真，除非当前进程改变它，否则该值就不会改变。

**Exit (kernel/proc.c:333)**记录退出状态，释放一些资源，将所有子进程交给**init**进程，在父进程处于等待状态时唤醒它，将*调用进程*标记为**zombie**，并永久放弃CPU。最后的序列有点棘手。退出的进程必须持有父进程的锁，同时将自己状态设置为**ZOMBIE**并唤醒父进程，因为父进程的锁是条件锁，可以防止在等待中丢失**wakeup**。子进程也必须持有自己的**p->lock**，否则父进程可能会看到它的状态为**ZOMBIE**，并在它还在运行时释放它。锁的获取顺序对避免死锁很重要：因为**wait**在子锁之前获取父锁，所以**exit**必须使用相同的顺序。

**Exit** 调用了一个专门的唤醒函数 **wakeup1**，它只唤醒父函数，而且只有父进程在**wait**中睡眠的情况下才会去唤醒它(kernel/proc.c:598)。在将自己的状态设置为**ZOMBIE**之前，唤醒父进程可能看起来并不正确，但这是安全的：尽管**wakeup1**可能会导致父进程运行，但**wait**中的循环不能检查子进程，直到子进程的**p->lock**被调度器释放为止，所以**wait**不能查看退出的进程，直到**exit**将其状态设置为**ZOMBIE**之后(kernel/proc.c:386)。

**exit**允许一个进程自行终止，而**kill**（kernel/proc.c:611）则允许一个进程请求另一个进程终止。如果让**kill**直接摧毁进程，那就太复杂了，因为相应进程可能在另一个CPU上执行，也许正处于更新内核数据结构的敏感序列中。因此，kill的作用很小：它只是设置进程的**p->killed**，如果它在**sleep**，则**wakeup**它。最终，进程会进入或离开内核，这时如果**p->killed**被设置，**usertrap**中的代码会调用**exit**。如果进程在用户空间运行，它将很快通过进行系统调用或因为定时器（或其他设备）中断而进入内核。

如果进程处于睡眠状态，**kill**调用**wakeup**会使进程从睡眠中返回。这是潜在的危险，因为正在等待的条件可能不为真。然而，xv6对**sleep**的调用总是被包裹在一个**while**循环中，在**sleep**返回后重新检测条件。一些对**sleep**的调用也会在循环中检测**p->killed**，如果设置了**p->killed**，则离开当前活动。只有当这种离开是正确的时候才会这样做。例如，管道读写代码如果设置了**killed**标志就会返回；最终代码会返回到trap，trap会再次检查标志并退出。

一些xv6 **sleep**循环没有检查**p->killed**，因为代码处于多步骤系统调用的中间，而这个调用应该是原子的。virtio驱动(kernel/virtio_disk.c:242)就是一个例子：它没有检查**p->killed**，因为磁盘操作可能是一系列写操作中的一个，而这些写操作都是为了让文件系统处于一个正确的状态而需要的。一个在等待磁盘I/O时被杀死的进程不会退出，直到它完成当前的系统调用和**usertrap**看到**killed**的标志。

### 6.5 真实世界的情况

xv6 调度器实现了一个简单的调度策略，它依次运行每个进程。这种策略被称为***轮询调度(round robin)\***。真正的操作系统实现了更复杂的策略，例如，允许进程有优先级。这个策略是，一个可运行的高优先级进程将被调度器优先于一个可运行的低优先级进程。这些策略可能会很快变得复杂，因为经常有相互竞争的目标：例如，操作者可能还想保证公平性和高吞吐量。此外，复杂的策略可能会导致不尽人意的交互，如***优先级倒置(priority inversion)\***和***护航现象(convoys\***)。当低优先级和高优先级进程共享一个锁时，就会发生优先级倒置，当低优先级进程获得锁时，就会阻止高优先级进程的进展。当许多高优先级进程都在等待一个获得共享锁的低优先级进程时，就会形成一个长长的等待进程的车队；一旦护航现象形成，就会持续很长时间。为了避免这类问题，在复杂的调度器中需要额外的机制。

**sleep**和**wakeup**是一种简单有效的同步方法，但还有很多其他的方法。在所有这些方法中，第一个挑战是避免我们在本章开头看到的丢失唤醒问题。最初的Unix内核的**sleep**只是禁用了中断，这已经足够了，因为Unix运行在单CPU系统上。因为xv6运行在多处理器上，所以它增加了一个显式的**sleep**锁。FreeBSD 的 **msleep** 采用了同样的方法。Plan 9的**sleep**使用了一个回调函数，它在进入睡眠前保持调度锁的情况下运行；这个函数的作用是在最后一刻检查**sleep**情况，以避免**wakeup**丢失。Linux内核的**sleep**使用一个显式的进程队列，称为等待队列，而不是等待通道；队列有自己的内部锁。

在**wakeup**过程中扫描整个进程链表，寻找相匹配的**chan**的进程，效率很低。一个更好的解决方案是用一个数据结构代替**sleep**和**wakeup**中的**chan**，该结构上存放着**sleep**的进程列表，比如Linux的等待队列。Plan 9的**sleep**和**wakeup**将该结构称为rendezvous point或Rendez。许多线程库将同一个结构称为条件变量；在这种情况下，sleep和wakeup的操作被称为**wait**和**signal**。所有这些机制都有相同的机制：睡眠条件被睡眠过程中原子地释放的锁保护。

**wakeup**唤醒了所有在某个特定**chan**上等待的进程，可能很多进程都在等待这个特定**chan**。操作系统会调度所有这些进程，它们会争相检查睡眠条件。以这种方式行事的进程有时被称为***惊群效应(\******thundering herd)\***，最好避免这种情况。大多数条件变量都有两个唤醒的基元：信号（signal），唤醒一个进程；广播（broadcast），唤醒所有等待的进程。

信号量通常用于同步。count通常对应于类似于管道缓冲区中可用的字节数或一个进程拥有的僵尸子进程的数量。使用显式计数作为抽象的一部分，可以避免丢失**wakeup**的问题：有一个显式的计数，说明已经发生的唤醒次数。该计数还避免了“虚假的”唤醒和***惊群效应\***问题。

终止进程和清理进程在xv6中引入了很多复杂性。在大多数操作系统中，它甚至更加复杂，因为，例如，被杀进程可能**trap**在内核中睡眠，而解除它的堆栈需要很多仔细的编程。许多操作系统使用显式的异常处理机制来解除堆栈，比如**longjmp[\**[1\]\**](#_ftn1)**。此外，还有其他一些事件可以导致一个睡眠进程被唤醒，即使它正在等待的事件还没有发生。例如，当一个Unix进程处于睡眠状态时，另一个进程可能会向它发送一个**signal**。在这种情况下，该进程将从中断的系统调用中返回，返回值为-1，错误代码设置为**EINTR**。应用程序可以检查这些值并决定做什么。Xv6不支持信号，也就不会出现这种复杂性。

Xv6对**kill**的支持并不完全令人满意：有些**sleep**循环可能应该检查**p->killed**。一个相关的问题是，即使是检查**p->killed**的**sleep**循环，在**sleep**和**kill**之间也会有一个竞争；**kill**可能会设置**p->killed**，并试图唤醒被杀进程，唤醒时刻发生在循环检查**p->killed**之后， 但在它调用**sleep**之前，就会发生。如果这个问题发生了，被杀进程不会注意到**p->killed**，直到它所等待的条件发生。这可能会晚很多（例如，当virtio驱动返回一个被杀进程正在等待的磁盘块时），也可能永远不会发生（例如，如果被杀进程正在等待来自控制台的输入，但用户没有键入任何输入）。

真正的操作系统会在常数时间内用显式的空闲列表来寻找空闲的进程，而不是在allocproc中进行线性时间的搜索；xv6为了简单起见，使用了线性扫描的方式。