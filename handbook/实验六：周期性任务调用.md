#### 实验六：周期性任务调用

**实验内容**

本实验要求你添加一个新特性：让进程在使用 CPU 的过程中能被周期性地通知。这一机制对于计算密集型的程序来说非常有用，比如希望限制自身 CPU 使用时间，或者在持续计算的同时需要周期性地执行某些操作的程序。更广义上讲，你将实现一种初级形式的**用户级中断/异常处理机制**。类似的机制可以被用于在应用层处理如页错误（page fault）等异常，因此具有重要的教学意义。只要你的实现能通过 `alarmtest` 和 `usertests` 的测试用例，就说明你的方案是正确的。

你需要添加一个新的系统调用：

```c
int sigalarm(int interval, void (*handler)());
```

当一个应用程序调用 `sigalarm(n, fn)` 后，系统应当在该程序每消耗 `n` 个时钟周期（tick）的 CPU 时间后，自动调用一次它提供的函数 `fn`。函数 `fn` 执行完毕后，用户程序应当**从原先中断的位置继续执行**。

> 注意：xv6 中的 “tick” 是由硬件定时器中断产生的时间单位，并不代表真实世界中的某个精确时间长度。这个时间间隔在系统中是固定的。

若应用程序调用 `sigalarm(0, 0)`，表示关闭之前注册的定时处理函数，系统应停止生成周期性通知。

你会在仓库中找到一个测试程序：`user/alarmtest.c`。请将其添加到 Makefile 的 `UPROGS` 列表中。在你实现 `sigalarm` 和 `sigreturn` 系统调用之前，该程序无法成功编译（`sigreturn` 系统调用用于从处理函数 `fn` 返回时恢复原上下文）。确保这两个系统调用的实现都完成后，再运行测试程序。

`alarmtest.c` 的测试函数 `test0()` 中，调用了 `sigalarm(2, periodic)`，即请求系统每过 2 个 tick 自动调用一次 `periodic()` 函数。随后该程序进入自旋状态。你可以查看 `user/alarmtest.asm` 中生成的汇编代码，这对于调试实现逻辑非常有帮助。

**实验现象**

若实验的实现是正确的，在shell中执行alarmtest会得到如下输出：

```
$ alarmtest
test0 start
............alarm!
test0 passed
test1 start
..alarm!
alarm!
.alarm!
.alarm!
.alarm!
..alarm!
.alarm!
..alarm!
.alarm!
..alarm!
test1 passed
test2 start
.......alarm!
test2 passed
```

**实验提示**

**test 0：**

首先，你需要修改内核，使其能够在用户进程中触发你注册的 alarm handler 函数。在这一阶段，`test0` 的目标是：当计时器中断触发时，能打印出 `"alarm!"`。目前不需要关心 `"alarm!"` 输出之后程序是否崩溃——如果能输出就说明你成功了一半。

- 你需要修改 `Makefile`，确保 `user/alarmtest.c` 能够被作为用户程序进行编译。

- 在 `user/user.h` 中添加如下声明：

  ```c
  int sigalarm(int ticks, void (*handler)());
  int sigreturn(void);
  ```

- 更新以下文件以支持新的系统调用：

  - `user/usys.pl`（生成 `usys.S`）
  - `include/syscall.h`
  - `process/proc/syscall.rs`

- 暂时可以让 `sys_sigreturn()` 直接返回 `0`，无需真正恢复上下文。

- 在 `struct proc`（定义于 `process/proc/mod.rs`）中添加字段来保存：

  - 报警周期 `interval`
  - 报警处理函数 `handler` 的地址

- 同时，你还需要增加一个字段记录自上一次报警以来的 tick 计数（或者距离下次报警还有多少 tick）。
   可在 `alloc_proc()`（定义在 `process/proc/mod.rs`）中初始化这些字段。

- 每一次时钟中断都会通过 `user_trap()`（位于 `src/trap.rs`）来处理。
   你只需要在设备类型为定时器中断时更新 alarm tick，例如：

  ```rust
   ScauseType::IntSSoft => {
      if CpuManager::cpu_id() == 0 {
          clock_intr();
      }
       ...
   }
  ```

- 如果进程没有注册处理函数，或周期为 0，则不应触发报警。
   注意：`handler` 的地址可能为 0（例如，在 `alarmtest.asm` 中 `periodic` 函数地址为 0）。

- 你需要在 `user_trap()` 中加入逻辑：当 alarm 到期后，应将用户态的下一条指令设置为 `handler` 函数地址，使得返回用户态后执行该函数。

- 在 RISC-V 上，trap 返回用户态执行的地址由 `sepc` 控制。

- 如果你能看到 `"alarm!"` 的输出，就说明 test0 成功。

------

**test 1/2:**

此时你可能会遇到以下问题：程序在输出 `"alarm!"` 后崩溃、输出 `"test1 failed"`，或直接退出却未显示 `"test1 passed"`。这些错误说明你**尚未正确恢复用户态进程的中断现场**。

要完成 `test1` 和 `test2`，你需要确保：

1. **handler 函数返回后，用户程序能继续从中断位置继续执行**。
2. **被中断前的所有寄存器状态都被正确恢复**。
3. **每次 handler 执行完毕后重新启动周期计数器，使得报警能持续触发**。

**设计要求：**

- 我们已经为你做出一个关键设计决策：**用户级 handler 必须在结束时调用 `sigreturn()` 系统调用**。
   查看 `alarmtest.c` 中的 `periodic()` 实现可以参考其调用方式。
- 这意味着你可以在 `user_trap()` 中保存中断现场，并在 `sys_sigreturn()` 中恢复这些状态，从而使程序能够从被打断的地方无缝继续执行。

**实现提示**：

- 你需要保存并恢复用户进程的大量寄存器。
  - **提示**：不只是 `a0-a7`，你还可能需要保存 `ra`、`sp`、`s0-s11`、`t0-t6` 等。
- 在 `usertrap()` 中，当定时器中断触发报警时，应保存全部用户寄存器到 `proc` 中的某个缓存结构里（例如 `trapframe_backup`），以备恢复。
- 在 `sigreturn()` 中，将 `trapframe_backup` 中保存的寄存器信息写回 `trapframe`，从而恢复现场。
- 要防止 handler 嵌套调用：如果上一次 handler 尚未执行完成，内核不能再次触发新的 handler 调用。
  - `test2` 会检测这一点。
- 当你成功通过 `test0`、`test1` 和 `test2` 后，**请务必运行 `usertests` 来验证你未破坏其它内核部分的行为正确性**。